---
layout: post
title: "block"
date: 2019-04-22 11:20:37 +0800
comments: true
categories: 
---
block的实现原理，对象模型<!--more-->
### 数据结构定义
从苹果的llvm[开源代码中](!http://clang.llvm.org/docs/Block-ABI-Apple.html#id2),我们可以看到block的数据结构定义如下
```javascript

struct Block_literal_1 {
   void *isa; // initialized to &_NSConcreteStackBlock or &_NSConcreteGlobalBlock
   int flags;
   int reserved;
   void (*invoke)(void *, ...);
   struct Block_descriptor_1 {
       unsigned long int reserved;         // NULL
       unsigned long int size;         // sizeof(struct Block_literal_1)
       // optional helper functions
       void (*copy_helper)(void *dst, void *src);     // IFF (1<<25)
       void (*dispose_helper)(void *src);             // IFF (1<<25)
       // required ABI.2010.3.16
       const char *signature;                         // IFF (1<<30)
   } *descriptor;
   // imported variables
};
```
通过上面的代码，我们可以知道，一个block对象实际是由6个部分组成

* isa指针：OC对象都有该指针，用于实现对象相关的功能。
* flags：用于按bit位表示一些block的附加信息。
* reserved：保留变量。
* invoke：函数指针，指向具体的block实现的函数调用地址，相当于clang编译器下的impl，命名不一样而已！
* descriptor：表示该block的附加描述信息，主要是size大小，以及copy和dispose函数的指针。
* variables：capture过来的变量，block能够访问它外部的局部变量，就是因为将这些变量(或变量的地址)复制到了结构体中。

该数据结构和clang分析出来的结构实际上是一样的，仅仅是结构体的嵌套方式不一样。比如，下面两个结构体的嵌套方式不一样，但是在内存上是完全一样的，原因是结构体本身并不带有任何额外的附加信息：
```javascript
struct SampleA {
   int a;
   int b;
   int c;
};

struct SampleB{
   int a;
   struct Part1 {
      int b;
   };
   struct Part2{
      int c;
   };
}
```
### 用clang分析block实现
新建工程，新建类test(这里类名和变量名最好不要用带block关键字的，因为后面clang后，变量名会自动填充一些关键字)。test.m中代码如下
```javascript
- (instancetype)init {

   self = [super init];
   if (self) {
   void(^test)(void) = ^(){

      NSLog(@"11");
   };
   test();
}
  return self;
}

```

执行clong，摘出主要代码如下。

```javascript
struct __block_impl {
   void *isa;
   int Flags;
   int Reserved;
   void *FuncPtr;
};

//这种就是之前说的 为什么尽量不要用block的命名，在执行clang之后，struct名是由类名+方法名的方式拼接成。
struct __test__init_block_impl_0 {
    struct __block_impl impl;
    struct __test__init_block_desc_0* Desc;
    __test__init_block_impl_0(void *fp, struct __test__init_block_desc_0 *desc, int flags=0) {
        impl.isa = &_NSConcreteStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
    }
};

static void __test__init_block_func_0(struct __test__init_block_impl_0 *__cself) {

    NSLog((NSString *)&__NSConstantStringImpl__var_folders_ng_8ncwcfkj69n6sh2hxlsfzz300000gn_T_test_0cd5eb_mi_0);
}

static struct __test__init_block_desc_0 {
    size_t reserved;
    size_t Block_size;
} __test__init_block_desc_0_DATA = { 0, sizeof(struct __test__init_block_impl_0)};

static instancetype _I_test_init(test * self, SEL _cmd) {

    self = ((test *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass("test"))}, sel_registerName("init"));
    if (self) {
        void(*test)(void) = ((void (*)())&__test__init_block_impl_0((void *)__test__init_block_func_0, &__test__init_block_desc_0_DATA));
        ((void (*)(__block_impl *))((__block_impl *)test)->FuncPtr)((__block_impl *)test);
}
    return self;
}

```



<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="通过runtime的源码跟踪alloc，最终我们发现会调用libmalloc中的calloc方法，那么calloc做了什么呢，让我们来一探究竟">
<meta name="keywords" content="libmalloc">
<meta property="og:type" content="article">
<meta property="og:title" content="缘起alloc">
<meta property="og:url" content="http://yfeii.github.io/2019/12/18/缘起alloc/index.html">
<meta property="og:site_name" content="逆水行舟">
<meta property="og:description" content="通过runtime的源码跟踪alloc，最终我们发现会调用libmalloc中的calloc方法，那么calloc做了什么呢，让我们来一探究竟">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/graphic_series/objc-alloc.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/libmalloc/E459E5EF-88BA-4A7B-95CF-18AB7FC2A4D4.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/libmalloc/B7416818-F049-4A70-9AD6-D1C6E367052E.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/libmalloc/0D92CDD7-7348-43C9-8BB9-1D6F54264B1D.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/libmalloc/0C3850FD-9AAE-4490-AE65-29355FB31A65.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/libmalloc/532E4275-3240-4ED8-A070-5CB1B6352E01.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/libmalloc/WeChatd6deae28d03f7b6849ac37a36dbab22f.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/libmalloc/8FB7E08B35EE88A4B0FEEC6C565CE1DA.png">
<meta property="og:updated_time" content="2019-12-29T14:59:41.930Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="缘起alloc">
<meta name="twitter:description" content="通过runtime的源码跟踪alloc，最终我们发现会调用libmalloc中的calloc方法，那么calloc做了什么呢，让我们来一探究竟">
<meta name="twitter:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/graphic_series/objc-alloc.png">





  
  
  <link rel="canonical" href="http://yfeii.github.io/2019/12/18/缘起alloc/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>缘起alloc | 逆水行舟</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逆水行舟</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yfeii.github.io/2019/12/18/缘起alloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yfeii">
      <meta itemprop="description" content="邮箱1486662452@qq.com，有问题欢迎留言评论或邮件。">
      <meta itemprop="image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/profile/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逆水行舟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">缘起alloc

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-18 14:19:02" itemprop="dateCreated datePublished" datetime="2019-12-18T14:19:02+08:00">2019-12-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-29 22:59:41" itemprop="dateModified" datetime="2019-12-29T22:59:41+08:00">2019-12-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS底层/" itemprop="url" rel="index"><span itemprop="name">iOS底层</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/12/18/缘起alloc/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/12/18/缘起alloc/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>通过<code>runtime</code>的源码跟踪<code>alloc</code>，最终我们发现会调用<code>libmalloc</code>中的<code>calloc</code>方法，那么<code>calloc</code>做了什么呢，让我们来一探究竟<a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将从<code>runtime</code>的<code>alloc</code>的最后流程讲起，为了方便回忆，先放一张<code>runtime</code> 创建实例的流程图。<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/graphic_series/objc-alloc.png" alt="img">。<br>重上面的图片我们看出 <code>runtime</code>的最终会调用<code>calloc</code>，而<code>calloc</code>方法被定义在libmalloc中。<br>本文使用的libmalloc 源码版本为 <a href="https://opensource.apple.com/source/libmalloc/libmalloc-166.251.2/" target="_blank" rel="noopener">libmalloc-166.251.2</a> 版本。</p>
<h2 id="malloc-zone-t"><a href="#malloc-zone-t" class="headerlink" title="malloc_zone_t"></a>malloc_zone_t</h2><p>先来看一个十分重要的机构体<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _malloc_zone_t &#123;</span><br><span class="line"><span class="comment">/* Only zone implementors should depend on the layout of this structure;</span></span><br><span class="line"><span class="comment">Regular callers should use the access functions below */</span></span><br><span class="line"><span class="keyword">void</span>    *reserved1;    <span class="comment">/* RESERVED FOR CFAllocator DO NOT USE */</span></span><br><span class="line"><span class="keyword">void</span>    *reserved2;    <span class="comment">/* RESERVED FOR CFAllocator DO NOT USE */</span></span><br><span class="line">size_t     (* MALLOC_ZONE_FN_PTR(size))(struct _malloc_zone_t *zone, <span class="keyword">const</span> <span class="keyword">void</span> *ptr); <span class="comment">/* returns the size of a block or 0 if not in this zone; must be fast, especially for negative answers */</span></span><br><span class="line"><span class="keyword">void</span>     *(* MALLOC_ZONE_FN_PTR(malloc))(struct _malloc_zone_t *zone, size_t size);</span><br><span class="line"><span class="keyword">void</span>     *(* MALLOC_ZONE_FN_PTR(calloc))(struct _malloc_zone_t *zone, size_t num_items, size_t size); <span class="comment">/* same as malloc, but block returned is set to zero */</span></span><br><span class="line"><span class="keyword">void</span>     *(* MALLOC_ZONE_FN_PTR(valloc))(struct _malloc_zone_t *zone, size_t size); <span class="comment">/* same as malloc, but block returned is set to zero and is guaranteed to be page aligned */</span></span><br><span class="line"><span class="keyword">void</span>     (* MALLOC_ZONE_FN_PTR(free))(struct _malloc_zone_t *zone, <span class="keyword">void</span> *ptr);</span><br><span class="line"><span class="keyword">void</span>     *(* MALLOC_ZONE_FN_PTR(realloc))(struct _malloc_zone_t *zone, <span class="keyword">void</span> *ptr, size_t size);</span><br><span class="line"><span class="keyword">void</span>     (* MALLOC_ZONE_FN_PTR(destroy))(struct _malloc_zone_t *zone); <span class="comment">/* zone is destroyed and all memory reclaimed */</span></span><br><span class="line"><span class="keyword">const</span> char    *zone_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Optional batch callbacks; these may be NULL */</span></span><br><span class="line">unsigned    (* MALLOC_ZONE_FN_PTR(batch_malloc))(struct _malloc_zone_t *zone, size_t size, <span class="keyword">void</span> **results, unsigned num_requested); <span class="comment">/* given a size, returns pointers capable of holding that size; returns the number of pointers allocated (maybe 0 or less than num_requested) */</span></span><br><span class="line"><span class="keyword">void</span>    (* MALLOC_ZONE_FN_PTR(batch_free))(struct _malloc_zone_t *zone, <span class="keyword">void</span> **to_be_freed, unsigned num_to_be_freed); <span class="comment">/* frees all the pointers in to_be_freed; note that to_be_freed may be overwritten during the process */</span></span><br><span class="line"></span><br><span class="line">struct malloc_introspection_t    * MALLOC_INTROSPECT_TBL_PTR(introspect);</span><br><span class="line">unsigned    version;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* aligned memory allocation. The callback may be NULL. Present in version &gt;= 5. */</span></span><br><span class="line"><span class="keyword">void</span> *(* MALLOC_ZONE_FN_PTR(memalign))(struct _malloc_zone_t *zone, size_t alignment, size_t size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free a pointer known to be in zone and known to have the given size. The callback may be NULL. Present in version &gt;= 6.*/</span></span><br><span class="line"><span class="keyword">void</span> (* MALLOC_ZONE_FN_PTR(free_definite_size))(struct _malloc_zone_t *zone, <span class="keyword">void</span> *ptr, size_t size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Empty out caches in the face of memory pressure. The callback may be NULL. Present in version &gt;= 8. */</span></span><br><span class="line">size_t     (* MALLOC_ZONE_FN_PTR(pressure_relief))(struct _malloc_zone_t *zone, size_t goal);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Checks whether an address might belong to the zone. May be NULL. Present in version &gt;= 10.</span></span><br><span class="line"><span class="comment">* False positives are allowed (e.g. the pointer was freed, or it's in zone space that has</span></span><br><span class="line"><span class="comment">* not yet been allocated. False negatives are not allowed.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">boolean_t (* MALLOC_ZONE_FN_PTR(claimed_address))(struct _malloc_zone_t *zone, <span class="keyword">void</span> *ptr);</span><br><span class="line">&#125; malloc_zone_t;</span><br></pre></td></tr></table></figure></p>
<p><code>malloc_zone_t</code>是一个非常基础结构，里面包含一堆函数指针，用来存储一堆相关的处理函数的具体实现的地址，例如malloc、free、realloc等函数的具体实现。后续会基于<code>malloc_zone_t</code>进行扩展。</p>
<h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h2><p>在<code>runtime</code> 的<code>alloc</code>阶段的最后调用的<code>calloc</code>函数实现如下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">calloc(size_t num_items, size_t size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span> *retval;</span><br><span class="line"><span class="comment">// 这个default_zone 是重点关注的对象</span></span><br><span class="line">retval = malloc_zone_calloc(default_zone, num_items, size);</span><br><span class="line"><span class="keyword">if</span> (retval == NULL) &#123;</span><br><span class="line">errno = ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="default-zone-引导"><a href="#default-zone-引导" class="headerlink" title="default_zone 引导"></a>default_zone 引导</h2><p>这个<code>default_zone</code>其实是一个“假的”zone，同时它也是<code>malloc_zone_t</code>类型。它存在的目的就是要引导程序进入一个创建真正的zone 的流程。下面来看一下default_zone的引导流程。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">malloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">MALLOC_TRACE(TRACE_calloc | DBG_FUNC_START, (uintptr_t)zone, num_items, size, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *ptr;</span><br><span class="line"><span class="keyword">if</span> (malloc_check_start &amp;&amp; (malloc_check_counter++ &gt;= malloc_check_start)) &#123;</span><br><span class="line">internal_check();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时传进来的 zone的类型是 上面calloc 传入的 defaultzone，所以zone-&gt;calloc的调用实现要看defaultzone 的定义。</span></span><br><span class="line">ptr = zone-&gt;calloc(zone, num_items, size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (malloc_logger) &#123;</span><br><span class="line">malloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE | MALLOC_LOG_TYPE_CLEARED, (uintptr_t)zone,</span><br><span class="line">(uintptr_t)(num_items * size), <span class="number">0</span>, (uintptr_t)ptr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MALLOC_TRACE(TRACE_calloc | DBG_FUNC_END, (uintptr_t)zone, num_items, size, (uintptr_t)ptr);</span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>defaultzone 的定义<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> virtual_default_zone_t virtual_default_zone</span><br><span class="line">__attribute__((section(<span class="string">"__DATA,__v_zone"</span>)))</span><br><span class="line">__attribute__((aligned(PAGE_MAX_SIZE))) = &#123;</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">default_zone_size,</span><br><span class="line">default_zone_malloc,</span><br><span class="line">default_zone_calloc,<span class="comment">//calloc的实现。</span></span><br><span class="line">default_zone_valloc,</span><br><span class="line">default_zone_free,</span><br><span class="line">default_zone_realloc,</span><br><span class="line">default_zone_destroy,</span><br><span class="line">DEFAULT_MALLOC_ZONE_STRING,</span><br><span class="line">default_zone_batch_malloc,</span><br><span class="line">default_zone_batch_free,</span><br><span class="line">&amp;default_zone_introspect,</span><br><span class="line"><span class="number">10</span>,</span><br><span class="line">default_zone_memalign,</span><br><span class="line">default_zone_free_definite_size,</span><br><span class="line">default_zone_pressure_relief,</span><br><span class="line">default_zone_malloc_claimed_address,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> malloc_zone_t *default_zone = &amp;virtual_default_zone.malloc_zone;</span><br></pre></td></tr></table></figure></p>
<p>从上面的结构可以看出 <code>defaultzone-&gt;calloc</code>实际的函数实现为<code>default_zone_calloc</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">default_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//引导创建真正的 zone。</span></span><br><span class="line">zone = runtime_default_zone();</span><br><span class="line"><span class="comment">//使用真正的zone 进行calloc</span></span><br><span class="line"><span class="keyword">return</span> zone-&gt;calloc(zone, num_items, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="zone"><a href="#zone" class="headerlink" title="zone"></a>zone</h2><p>在创建正在的zone时，其实系统是有对应的一套创建策略的。在跟踪<code>runtime_default_zone</code>方法后，最终会进入如下调用<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/libmalloc/E459E5EF-88BA-4A7B-95CF-18AB7FC2A4D4.png" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_malloc_initialize(<span class="keyword">void</span> *context __unused)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//创建helper_zone,</span></span><br><span class="line">malloc_zone_t *helper_zone = create_scalable_zone(<span class="number">0</span>, malloc_debug_flags);</span><br><span class="line"><span class="comment">//创建 nano zone</span></span><br><span class="line"><span class="keyword">if</span> (_malloc_engaged_nano == NANO_V2) &#123;</span><br><span class="line">zone = nanov2_create_zone(helper_zone, malloc_debug_flags);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (_malloc_engaged_nano == NANO_V1) &#123;</span><br><span class="line">zone = nano_create_zone(helper_zone, malloc_debug_flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果上面的if else if 成立，这进入 nonazone</span></span><br><span class="line"><span class="keyword">if</span> (zone) &#123;</span><br><span class="line">malloc_zone_register_while_locked(zone);</span><br><span class="line">malloc_zone_register_while_locked(helper_zone);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Must call malloc_set_zone_name() *after* helper and nano are hooked together.</span></span><br><span class="line">malloc_set_zone_name(zone, DEFAULT_MALLOC_ZONE_STRING);</span><br><span class="line">malloc_set_zone_name(helper_zone, MALLOC_HELPER_ZONE_STRING);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//使用helper_zone分配内存</span></span><br><span class="line">zone = helper_zone;</span><br><span class="line">malloc_zone_register_while_locked(zone);</span><br><span class="line">malloc_set_zone_name(zone, DEFAULT_MALLOC_ZONE_STRING);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓存default_zone</span></span><br><span class="line">initial_default_zone = zone;</span><br><span class="line"></span><br><span class="line">.....    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里 会存在两种zone</p>
<ol>
<li>nanozone_t</li>
<li>scalable_zone</li>
</ol>
<h3 id="nanozone-t"><a href="#nanozone-t" class="headerlink" title="nanozone_t"></a>nanozone_t</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct nano_meta_s &#123;</span><br><span class="line">OSQueueHead            slot_LIFO MALLOC_NANO_CACHE_ALIGN;</span><br><span class="line">unsigned int        slot_madvised_log_page_count;</span><br><span class="line">volatile uintptr_t        slot_current_base_addr;</span><br><span class="line">volatile uintptr_t        slot_limit_addr;</span><br><span class="line">volatile size_t        slot_objects_mapped;</span><br><span class="line">volatile size_t        slot_objects_skipped;</span><br><span class="line">bitarray_t            slot_madvised_pages;</span><br><span class="line"><span class="comment">// position on cache line distinct from that of slot_LIFO</span></span><br><span class="line">volatile uintptr_t        slot_bump_addr MALLOC_NANO_CACHE_ALIGN;</span><br><span class="line">volatile boolean_t        slot_exhausted;</span><br><span class="line">unsigned int        slot_bytes;</span><br><span class="line">unsigned int        slot_objects;</span><br><span class="line">&#125; *nano_meta_admin_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vm_allocate()'d, so page-aligned to begin with.</span></span><br><span class="line">typedef struct nanozone_s &#123;</span><br><span class="line"><span class="comment">// first page will be given read-only protection</span></span><br><span class="line">malloc_zone_t        basic_zone;</span><br><span class="line">uint8_t            pad[PAGE_MAX_SIZE - sizeof(malloc_zone_t)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// remainder of structure is R/W (contains no function pointers)</span></span><br><span class="line"><span class="comment">// page-aligned</span></span><br><span class="line"><span class="comment">// max: NANO_MAG_SIZE cores x NANO_SLOT_SIZE slots for nano blocks &#123;16 .. 256&#125;</span></span><br><span class="line"><span class="comment">//以Mag、Slot为维度，维护申请的band内存部分 slot 的范围为 1~16</span></span><br><span class="line">struct nano_meta_s        meta_data[NANO_MAG_SIZE][NANO_SLOT_SIZE];<span class="comment">//</span></span><br><span class="line">_malloc_lock_s            band_resupply_lock[NANO_MAG_SIZE];</span><br><span class="line">uintptr_t           band_max_mapped_baseaddr[NANO_MAG_SIZE];</span><br><span class="line">size_t            core_mapped_size[NANO_MAG_SIZE];</span><br><span class="line"></span><br><span class="line">unsigned            debug_flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* security cookie */</span></span><br><span class="line">uintptr_t            cookie;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* The nano zone constructed by create_nano_zone() would like to hand off tiny, small, and large</span></span><br><span class="line"><span class="comment">* allocations to the default scalable zone. Record the latter as the "helper" zone here.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">malloc_zone_t        *helper_zone;</span><br><span class="line">&#125; nanozone_t;</span><br></pre></td></tr></table></figure>
<p><code>nanozone_t</code>同样是<code>malloc_zone_t</code>类型。在<code>nano_create_zone</code>函数内部会完成对<code>calloc</code>等函数的重新赋值。  </p>
<h4 id="nano-create-zone"><a href="#nano-create-zone" class="headerlink" title="nano_create_zone"></a>nano_create_zone</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">malloc_zone_t *</span><br><span class="line">nano_create_zone(malloc_zone_t *helper_zone, unsigned debug_flags)</span><br><span class="line">&#123;</span><br><span class="line">    nanozone_t *nanozone;</span><br><span class="line">    int i, j;</span><br><span class="line">    //构造nano zone</span><br><span class="line">    /* Note: It is important that nano_create_zone resets _malloc_engaged_nano</span><br><span class="line">     * if it is unable to enable the nanozone (and chooses not to abort). As</span><br><span class="line">     * several functions rely on _malloc_engaged_nano to determine if they</span><br><span class="line">     * should manipulate the nanozone, and these should not run if we failed</span><br><span class="line">     * to create the zone.</span><br><span class="line">     */</span><br><span class="line">//     MALLOC_ASSERT(_malloc_engaged_nano == NANO_V1);</span><br><span class="line"></span><br><span class="line">    /* get memory for the zone. */</span><br><span class="line">    nanozone = nano_common_allocate_based_pages(NANOZONE_PAGED_SIZE, 0, 0, VM_MEMORY_MALLOC, 0);</span><br><span class="line">    if (!nanozone) &#123;</span><br><span class="line">        _malloc_engaged_nano = NANO_NONE;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    //构造对zone 的一些函数进行重新赋值</span><br><span class="line">    /* set up the basic_zone portion of the nanozone structure */</span><br><span class="line">    nanozone-&gt;basic_zone.version = 10;</span><br><span class="line">    nanozone-&gt;basic_zone.size = (void *)nano_size;</span><br><span class="line">    nanozone-&gt;basic_zone.malloc = (debug_flags &amp; MALLOC_DO_SCRIBBLE) ? (void *)nano_malloc_scribble : (void *)nano_malloc;</span><br><span class="line">    nanozone-&gt;basic_zone.calloc = (void *)nano_calloc;</span><br><span class="line">    nanozone-&gt;basic_zone.valloc = (void *)nano_valloc;</span><br><span class="line">    nanozone-&gt;basic_zone.free = (debug_flags &amp; MALLOC_DO_SCRIBBLE) ? (void *)nano_free_scribble : (void *)nano_free;</span><br><span class="line">    nanozone-&gt;basic_zone.realloc = (void *)nano_realloc;</span><br><span class="line">    nanozone-&gt;basic_zone.destroy = (void *)nano_destroy;</span><br><span class="line">    nanozone-&gt;basic_zone.batch_malloc = (void *)nano_batch_malloc;</span><br><span class="line">    nanozone-&gt;basic_zone.batch_free = (void *)nano_batch_free;</span><br><span class="line">    nanozone-&gt;basic_zone.introspect = (struct malloc_introspection_t *)&amp;nano_introspect;</span><br><span class="line">    nanozone-&gt;basic_zone.memalign = (void *)nano_memalign;</span><br><span class="line">    nanozone-&gt;basic_zone.free_definite_size = (debug_flags &amp; MALLOC_DO_SCRIBBLE) ? (void *)nano_free_definite_size_scribble</span><br><span class="line">                                                                                          : (void *)nano_free_definite_size;</span><br><span class="line"></span><br><span class="line">    nanozone-&gt;basic_zone.pressure_relief = (void *)nano_pressure_relief;</span><br><span class="line">    nanozone-&gt;basic_zone.claimed_address = (void *)nano_claimed_address;</span><br><span class="line"></span><br><span class="line">    nanozone-&gt;basic_zone.reserved1 = 0; /* Set to zero once and for all as required by CFAllocator. */</span><br><span class="line">    nanozone-&gt;basic_zone.reserved2 = 0; /* Set to zero once and for all as required by CFAllocator. */</span><br><span class="line"></span><br><span class="line">    mprotect(nanozone, sizeof(nanozone-&gt;basic_zone), PROT_READ); /* Prevent overwriting the function pointers in basic_zone. */</span><br><span class="line"></span><br><span class="line">    /* Nano zone does not support MALLOC_ADD_GUARD_PAGES. */</span><br><span class="line">    if (debug_flags &amp; MALLOC_ADD_GUARD_PAGES) &#123;</span><br><span class="line">        malloc_report(ASL_LEVEL_INFO, &quot;nano zone does not support guard pages\n&quot;);</span><br><span class="line">        debug_flags &amp;= ~MALLOC_ADD_GUARD_PAGES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* set up the remainder of the nanozone structure */</span><br><span class="line">    nanozone-&gt;debug_flags = debug_flags;</span><br><span class="line"></span><br><span class="line">    if (phys_ncpus &gt; sizeof(nanozone-&gt;core_mapped_size) /</span><br><span class="line">            sizeof(nanozone-&gt;core_mapped_size[0])) &#123;</span><br><span class="line">        MALLOC_REPORT_FATAL_ERROR(phys_ncpus,</span><br><span class="line">                &quot;nanozone abandoned because NCPUS &gt; max magazines.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Initialize slot queue heads and resupply locks. */</span><br><span class="line">    OSQueueHead q0 = OS_ATOMIC_QUEUE_INIT;</span><br><span class="line">    for (i = 0; i &lt; nano_common_max_magazines; ++i) &#123;</span><br><span class="line">        _malloc_lock_init(&amp;nanozone-&gt;band_resupply_lock[i]);</span><br><span class="line"></span><br><span class="line">        for (j = 0; j &lt; NANO_SLOT_SIZE; ++j) &#123;</span><br><span class="line">            nanozone-&gt;meta_data[i][j].slot_LIFO = q0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Initialize the security token. */</span><br><span class="line">    nanozone-&gt;cookie = (uintptr_t)malloc_entropy[0] &amp; 0x0000ffffffff0000ULL; // scramble central 32bits with this cookie</span><br><span class="line"></span><br><span class="line">    nanozone-&gt;helper_zone = helper_zone;</span><br><span class="line"></span><br><span class="line">    return (malloc_zone_t *)nanozone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="nano-calloc"><a href="#nano-calloc" class="headerlink" title="nano_calloc"></a>nano_calloc</h4><p>过程参考<code>defaultzone</code>。回到上面<code>default_zone_calloc</code>函数内。下一步就是使用<code>nanozone_t</code>调用<code>calloc</code>。<br>下面是<code>nano_calloc</code>的实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">nano_calloc(nanozone_t *nanozone, size_t num_items, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    size_t total_bytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (calloc_get_size(num_items, size, <span class="number">0</span>, &amp;total_bytes)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果要开辟的空间小于 NANO_MAX_SIZE 则进行nanozone_t的malloc。</span></span><br><span class="line">    <span class="keyword">if</span> (total_bytes &lt;= NANO_MAX_SIZE) &#123;</span><br><span class="line">        <span class="keyword">void</span> *p = _nano_malloc_check_clear(nanozone, total_bytes, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* FALLTHROUGH to helper zone */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则就进行helper_zone的流程</span></span><br><span class="line">    malloc_zone_t *zone = (malloc_zone_t *)(nanozone-&gt;helper_zone);</span><br><span class="line">    <span class="keyword">return</span> zone-&gt;calloc(zone, <span class="number">1</span>, total_bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="nano-malloc-check-clear"><a href="#nano-malloc-check-clear" class="headerlink" title="_nano_malloc_check_clear"></a>_nano_malloc_check_clear</h4><p>这里我们也可以看出使用<code>nanozone_t</code>的限制为不超过256B。继续看<code>_nano_malloc_check_clear</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_nano_malloc_check_clear(nanozone_t *nanozone, size_t size, boolean_t cleared_requested)</span><br><span class="line">&#123;</span><br><span class="line">    MALLOC_TRACE(TRACE_nano_malloc, (uintptr_t)nanozone, size, cleared_requested, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    size_t slot_key;</span><br><span class="line">    <span class="comment">//获取16字节对齐之后的大小,slot_key非常关键，为slot_bytes/16的值，也是数组的二维下下标</span></span><br><span class="line">    size_t slot_bytes = segregated_size_to_fit(nanozone, size, &amp;slot_key); <span class="comment">// Note slot_key is set here</span></span><br><span class="line">    <span class="comment">//根据_os_cpu_number经过运算获取 mag_index(meta_data的一维索引)</span></span><br><span class="line">    mag_index_t mag_index = nano_mag_index(nanozone);</span><br><span class="line">    <span class="comment">//确定当前cpu对应的mag和通过size参数计算出来的slot，去对应metadata的链表中取已经被释放过的内存区块缓存</span></span><br><span class="line">    nano_meta_admin_t pMeta = &amp;(nanozone-&gt;meta_data[mag_index][slot_key]);</span><br><span class="line">    <span class="comment">//检测是否存在已经释放过，可以直接拿来用的内存,已经被释放的内存会缓存在 chained_block_s 链表</span></span><br><span class="line">    <span class="comment">//每一次free。同样会根据 index 和slot 的值回去 pMeta，然后把slot_LIFO的指针指向释放的内存。</span></span><br><span class="line">    ptr = OSAtomicDequeue(&amp;(pMeta-&gt;slot_LIFO), offsetof(struct chained_block_s, next));</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果缓存的内存存在，这进行指针地址检查等异常检测，最后返回</span></span><br><span class="line">    <span class="comment">//第一次调用malloc时，不会执行这一块代码。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//没有释放过的内存，所以调用函数 获取内存</span></span><br><span class="line">        ptr = segregated_next_block(nanozone, pMeta, slot_bytes, mag_index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cleared_requested &amp;&amp; ptr) &#123;</span><br><span class="line">        memset(ptr, <span class="number">0</span>, slot_bytes); <span class="comment">// <span class="doctag">TODO:</span> Needs a memory barrier after memset to ensure zeroes land first?</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法主要是通过cpu与slot确定index，从<code>chained_block_s</code>链表中找出是否存在已经释放过的缓存。如果存在则进行指针检查之后返回，否则进入查询<code>meta data</code>或者开辟band。</p>
<h4 id="segregated-next-block"><a href="#segregated-next-block" class="headerlink" title="segregated_next_block"></a>segregated_next_block</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MALLOC_INLINE <span class="keyword">void</span> *</span><br><span class="line">segregated_next_block(nanozone_t *nanozone, nano_meta_admin_t pMeta, size_t slot_bytes, unsigned int mag_index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//当前这块pMeta可用内存的结束地址</span></span><br><span class="line">        uintptr_t theLimit = pMeta-&gt;slot_limit_addr; <span class="comment">// Capture the slot limit that bounds slot_bump_addr right now</span></span><br><span class="line">        <span class="comment">//原子的为pMeta-&gt;slot_bump_addr添加slot_bytes的长度，偏移到下一个地址</span></span><br><span class="line">        uintptr_t b = OSAtomicAdd64Barrier(slot_bytes, (volatile int64_t *)&amp;(pMeta-&gt;slot_bump_addr));</span><br><span class="line">        <span class="comment">//减去添加的偏移量，获取当前可以获取的地址</span></span><br><span class="line">        b -= slot_bytes; <span class="comment">// Atomic op returned addr of *next* free block. Subtract to get addr for *this* allocation.</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (b &lt; theLimit) &#123;   <span class="comment">// Did we stay within the bound of the present slot allocation?</span></span><br><span class="line">            <span class="comment">//如果地址还在范围之内，则返回地址</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">void</span> *)b; <span class="comment">// Yep, so the slot_bump_addr this thread incremented is good to go</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//已经用尽了</span></span><br><span class="line">            <span class="keyword">if</span> (pMeta-&gt;slot_exhausted) &#123; <span class="comment">// exhausted all the bands availble for this slot?</span></span><br><span class="line">                pMeta-&gt;slot_bump_addr = theLimit;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;                 <span class="comment">// We're toast</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// One thread will grow the heap, others will see its been grown and retry allocation</span></span><br><span class="line">                _malloc_lock_lock(&amp;nanozone-&gt;band_resupply_lock[mag_index]);</span><br><span class="line">                <span class="comment">// re-check state now that we've taken the lock</span></span><br><span class="line">                <span class="comment">//多线程的缘故，重新检查是否用尽</span></span><br><span class="line">                <span class="keyword">if</span> (pMeta-&gt;slot_exhausted) &#123;</span><br><span class="line">                    _malloc_lock_unlock(&amp;nanozone-&gt;band_resupply_lock[mag_index]);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Toast</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &lt; pMeta-&gt;slot_limit_addr) &#123;</span><br><span class="line">                    <span class="comment">//如果小于最大限制地址，当重新申请一个新的band后，重新尝试while</span></span><br><span class="line">                    _malloc_lock_unlock(&amp;nanozone-&gt;band_resupply_lock[mag_index]);</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// ... the slot was successfully grown by first-taker (not us). Now try again.</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (segregated_band_grow(nanozone, pMeta, slot_bytes, mag_index)) &#123;</span><br><span class="line">                    <span class="comment">//申请新的band成功，重新尝试while</span></span><br><span class="line">                    _malloc_lock_unlock(&amp;nanozone-&gt;band_resupply_lock[mag_index]);</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// ... the slot has been successfully grown by us. Now try again.</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pMeta-&gt;slot_exhausted = TRUE;</span><br><span class="line">                    pMeta-&gt;slot_bump_addr = theLimit;</span><br><span class="line">                    _malloc_lock_unlock(&amp;nanozone-&gt;band_resupply_lock[mag_index]);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是第一次调用<code>segregated_next_block</code>函数，band不存在，缓存也不会存在，所以会调用<code>segregated_band_grow</code>。来开辟新的band</p>
<h4 id="segregated-band-grow"><a href="#segregated-band-grow" class="headerlink" title="segregated_band_grow"></a>segregated_band_grow</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">boolean_t</span><br><span class="line">segregated_band_grow(nanozone_t *nanozone, nano_meta_admin_t pMeta, size_t slot_bytes, unsigned int mag_index)</span><br><span class="line">&#123;</span><br><span class="line">    用来计算slot_current_base_addr 的联合体</span><br><span class="line">    nano_blk_addr_t u; <span class="comment">// the compiler holds this in a register</span></span><br><span class="line">    uintptr_t p, s;</span><br><span class="line">    size_t watermark, hiwater;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == pMeta-&gt;slot_current_base_addr) &#123; <span class="comment">// First encounter?</span></span><br><span class="line">        <span class="comment">//利用nano_blk_addr_t 来计算slot_current_base_addr。</span></span><br><span class="line">        u.fields.nano_signature = NANOZONE_SIGNATURE;</span><br><span class="line">        u.fields.nano_mag_index = mag_index;</span><br><span class="line">        u.fields.nano_band = <span class="number">0</span>;</span><br><span class="line">        u.fields.nano_slot = (slot_bytes &gt;&gt; SHIFT_NANO_QUANTUM) - <span class="number">1</span>;</span><br><span class="line">        u.fields.nano_offset = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据设置的属性计算 slot_current_base_addr </span></span><br><span class="line">        p = u.addr;</span><br><span class="line">        pMeta-&gt;slot_bytes = (unsigned int)slot_bytes;</span><br><span class="line">        pMeta-&gt;slot_objects = SLOT_IN_BAND_SIZE / slot_bytes;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = pMeta-&gt;slot_current_base_addr + BAND_SIZE; <span class="comment">// Growing, so stride ahead by BAND_SIZE</span></span><br><span class="line"></span><br><span class="line">        u.addr = (uint64_t)p;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == u.fields.nano_band) &#123; <span class="comment">// Did the band index wrap?</span></span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        assert(slot_bytes == pMeta-&gt;slot_bytes);</span><br><span class="line">    &#125;</span><br><span class="line">    pMeta-&gt;slot_current_base_addr = p;</span><br><span class="line"><span class="comment">//BAND_SIZE = 1 &lt;&lt; 21 = 2097152 = 256kb</span></span><br><span class="line">    mach_vm_address_t vm_addr = p &amp; ~((uintptr_t)(BAND_SIZE - <span class="number">1</span>)); <span class="comment">// Address of the (2MB) band covering this (128KB) slot</span></span><br><span class="line">    <span class="keyword">if</span> (nanozone-&gt;band_max_mapped_baseaddr[mag_index] &lt; vm_addr) &#123;</span><br><span class="line">    <span class="comment">//如果最大能存储的地址 仍然小于目标地址，则小开辟新的band</span></span><br><span class="line">#if !NANO_PREALLOCATE_BAND_VM</span><br><span class="line">        <span class="comment">// Obtain the next band to cover this slot</span></span><br><span class="line">        <span class="comment">//// mac 和模拟器 或重新使用</span></span><br><span class="line">        <span class="comment">// Obtain the next band to cover this slot</span></span><br><span class="line">        <span class="comment">//重新申请新的 band，调用mach_vm_map  从pmap 转换。</span></span><br><span class="line">        kern_return_t kr = mach_vm_map(mach_task_self(), &amp;vm_addr, BAND_SIZE, <span class="number">0</span>, VM_MAKE_TAG(VM_MEMORY_MALLOC_NANO),</span><br><span class="line">                MEMORY_OBJECT_NULL, <span class="number">0</span>, FALSE, VM_PROT_DEFAULT, VM_PROT_ALL, VM_INHERIT_DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> *q = (<span class="keyword">void</span> *)vm_addr;</span><br><span class="line">        <span class="keyword">if</span> (kr || q != (<span class="keyword">void</span> *)(p &amp; ~((uintptr_t)(BAND_SIZE - <span class="number">1</span>)))) &#123; <span class="comment">// Must get exactly what we asked for</span></span><br><span class="line">            <span class="keyword">if</span> (!kr) &#123;</span><br><span class="line">                mach_vm_deallocate(mach_task_self(), vm_addr, BAND_SIZE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        nanozone-&gt;band_max_mapped_baseaddr[mag_index] = vm_addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Randomize the starting allocation from this slot (introduces 11 to 14 bits of entropy)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == pMeta-&gt;slot_objects_mapped) &#123; <span class="comment">// First encounter?</span></span><br><span class="line">        pMeta-&gt;slot_objects_skipped = (malloc_entropy[<span class="number">1</span>] % (SLOT_IN_BAND_SIZE / slot_bytes));</span><br><span class="line">        pMeta-&gt;slot_bump_addr = p + (pMeta-&gt;slot_objects_skipped * slot_bytes);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pMeta-&gt;slot_bump_addr = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pMeta-&gt;slot_limit_addr = p + (SLOT_IN_BAND_SIZE / slot_bytes) * slot_bytes;</span><br><span class="line">    pMeta-&gt;slot_objects_mapped += (SLOT_IN_BAND_SIZE / slot_bytes);</span><br><span class="line"></span><br><span class="line">    u.fields.nano_signature = NANOZONE_SIGNATURE;</span><br><span class="line">    u.fields.nano_mag_index = mag_index;</span><br><span class="line">    u.fields.nano_band = <span class="number">0</span>;</span><br><span class="line">    u.fields.nano_slot = <span class="number">0</span>;</span><br><span class="line">    u.fields.nano_offset = <span class="number">0</span>;</span><br><span class="line">    s = u.addr; <span class="comment">// Base for this core.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the high water mark for this CPU's entire magazine, if this resupply raised it.</span></span><br><span class="line">    watermark = nanozone-&gt;core_mapped_size[mag_index];</span><br><span class="line">    hiwater = MAX(watermark, p - s + SLOT_IN_BAND_SIZE);</span><br><span class="line">    nanozone-&gt;core_mapped_size[mag_index] = hiwater;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当进入<code>segregated_band_grow</code>时，如果当前的band不够用，则使用<code> mach_vm_map</code>经由<code>pmap</code>重新映射物理内存到虚拟内存。<br>关于通过<code>nano_blk_addr_t</code>的联合体结构如下，其每个成员所占的bit位数已经写出。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct nano_blk_addr_s &#123;</span><br><span class="line">    uint64_t                                   </span><br><span class="line">    nano_offset:NANO_OFFSET_BITS,              <span class="comment">//17 locates the block</span></span><br><span class="line">    nano_slot:NANO_SLOT_BITS,                  <span class="comment">//4  bucket of homogenous quanta-multiple blocks</span></span><br><span class="line">    nano_band:NANO_BAND_BITS,                  <span class="comment">//17</span></span><br><span class="line">    nano_mag_index:NANO_MAG_BITS,              <span class="comment">//6  the core that allocated this block</span></span><br><span class="line">    nano_signature:NANOZONE_SIGNATURE_BITS;    <span class="comment">//   the address range devoted to us.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"><span class="comment">// clang-format on</span></span><br><span class="line"></span><br><span class="line">typedef union  &#123;</span><br><span class="line">    uint64_t            addr;</span><br><span class="line">    struct nano_blk_addr_s    fields;</span><br><span class="line">&#125; nano_blk_addr_t;</span><br></pre></td></tr></table></figure></p>
<p>结合下面的例子<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/libmalloc/B7416818-F049-4A70-9AD6-D1C6E367052E.png" alt="img"><br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/libmalloc/0D92CDD7-7348-43C9-8BB9-1D6F54264B1D.png" alt="img"><br>在free的阶段，也是使用如上的方式获取 对应的 slot，mag_index。  </p>
<p>下面来梳理下nana_zone分配过程：</p>
<blockquote>
<p>确定当前cpu对应的mag和通过size参数计算出来的slot，去对应<code>chained_block_s</code>的链表中取已经被释放过的内存区块缓存，如果取到检查指针地址是否有问题，没有问题就直接返回；<br>初次进行<code>nano malloc</code>时，<code>nano zon</code>并没有缓存，会直接在<code>nano zone</code>范围的地址空间上直接分配连续地址内存；<br>如当前<code>Band</code>中当前<code>Slot</code>耗尽则向系统申请新的<code>Band</code>（每个Band固定大小2M，容纳了16个128k的槽），连续地址分配内存的基地址、limit地址以及当前分配到的地址由<code>meta data</code>结构维护起来，而这些<code>meta data</code>则以<code>Mag、Slot</code>为维度（Mag个数是处理器个数，Slot是16个）的二维数组形式，放在<code>nanozone_t</code>的<code>meta_data</code>字段中。<br>流程如下<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/libmalloc/0C3850FD-9AAE-4490-AE65-29355FB31A65.png" alt="img"></p>
</blockquote>
<h3 id="scalable-zone-helper-zone"><a href="#scalable-zone-helper-zone" class="headerlink" title="scalable zone(helper_zone)"></a>scalable zone(helper_zone)</h3><p>在szone上分配的内存包括tiny、small和large三大类，其中tiny和small的分配、释放过程大致相同，large类型有自己的方式管理。同样会通过<code>create_scalable_zone</code>来构造zone。<br>这里不在复述<code>create_scalable_zone</code>，直接看内存的分配策略</p>
<h4 id="szone-malloc-should-clear"><a href="#szone-malloc-should-clear" class="headerlink" title="szone_malloc_should_clear"></a>szone_malloc_should_clear</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">MALLOC_NOINLINE <span class="keyword">void</span> *</span><br><span class="line">szone_malloc_should_clear(szone_t *szone, size_t size, boolean_t cleared_requested)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    msize_t msize;</span><br><span class="line">    <span class="comment">//64位 &lt;= 1008B  32位&lt;= 496B</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= SMALL_THRESHOLD) &#123;</span><br><span class="line">        <span class="comment">// tiny size: &lt;=1008 bytes (64-bit), &lt;=496 bytes (32-bit)</span></span><br><span class="line">        <span class="comment">// think tiny</span></span><br><span class="line">        msize = TINY_MSIZE_FOR_BYTES(size + TINY_QUANTUM - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!msize) &#123;</span><br><span class="line">            msize = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = tiny_malloc_should_clear(&amp;szone-&gt;tiny_rack, msize, cleared_requested);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= szone-&gt;large_threshold) &#123;</span><br><span class="line">        <span class="comment">//64位 &lt;= 128KB      32位 &lt;= 128KB</span></span><br><span class="line">        <span class="comment">// small size: &lt;=15k (iOS), &lt;=64k (large iOS), &lt;=128k (macOS)</span></span><br><span class="line">        <span class="comment">// think small</span></span><br><span class="line">        msize = SMALL_MSIZE_FOR_BYTES(size + SMALL_QUANTUM - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!msize) &#123;</span><br><span class="line">            msize = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = small_malloc_should_clear(&amp;szone-&gt;small_rack, msize, cleared_requested);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// large: all other allocations</span></span><br><span class="line">        size_t num_kernel_pages = round_page_quanta(size) &gt;&gt; vm_page_quanta_shift;</span><br><span class="line">        <span class="keyword">if</span> (num_kernel_pages == <span class="number">0</span>) &#123; <span class="comment">/* Overflowed */</span></span><br><span class="line">            ptr = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ptr = large_malloc(szone, num_kernel_pages, <span class="number">0</span>, cleared_requested);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#if DEBUG_MALLOC</span><br><span class="line">    <span class="keyword">if</span> (LOG(szone, ptr)) &#123;</span><br><span class="line">        malloc_report(ASL_LEVEL_INFO, <span class="string">"szone_malloc returned %p\n"</span>, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If requested, scribble on allocated memory.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((szone-&gt;debug_flags &amp; MALLOC_DO_SCRIBBLE) &amp;&amp; ptr &amp;&amp; !cleared_requested &amp;&amp; size) &#123;</span><br><span class="line">        memset(ptr, SCRIBBLE_BYTE, szone_size(szone, ptr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里以看出在szone上分配的内存包括tiny、small和large三大类，我们以tiny为例</p>
<h4 id="tiny-malloc-should-clear"><a href="#tiny-malloc-should-clear" class="headerlink" title="tiny_malloc_should_clear"></a>tiny_malloc_should_clear</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">tiny_malloc_should_clear(rack_t *rack, msize_t msize, boolean_t cleared_requested)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    mag_index_t mag_index = tiny_mag_get_thread_index() % rack-&gt;num_magazines;</span><br><span class="line">    <span class="comment">//获取magazine.  magazines 是一个由64个magazine_t组成的数组</span></span><br><span class="line">    magazine_t *tiny_mag_ptr = &amp;(rack-&gt;magazines[mag_index]);</span><br><span class="line"></span><br><span class="line">    MALLOC_TRACE(TRACE_tiny_malloc, (uintptr_t)rack, TINY_BYTES_FOR_MSIZE(msize), (uintptr_t)tiny_mag_ptr, cleared_requested);</span><br><span class="line"></span><br><span class="line">#if DEBUG_MALLOC</span><br><span class="line">    <span class="keyword">if</span> (DEPOT_MAGAZINE_INDEX == mag_index) &#123;</span><br><span class="line">        malloc_zone_error(rack-&gt;debug_flags, <span class="literal">true</span>, <span class="string">"malloc called for magazine index -1\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> (NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!msize) &#123;</span><br><span class="line">        malloc_zone_error(rack-&gt;debug_flags, <span class="literal">true</span>, <span class="string">"invariant broken (!msize) in allocation (region)\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> (NULL);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);</span><br><span class="line"></span><br><span class="line">#if CONFIG_TINY_CACHE</span><br><span class="line">    ptr = tiny_mag_ptr-&gt;mag_last_free;</span><br><span class="line">    <span class="comment">//如果开启了tiny 的缓存。</span></span><br><span class="line">    <span class="keyword">if</span> (tiny_mag_ptr-&gt;mag_last_free_msize == msize) &#123;</span><br><span class="line">        <span class="comment">// we have a winner</span></span><br><span class="line">        <span class="comment">//优先查看上次最后释放的区块是否和此次请求的大小刚好相等（都是对齐之后的slot大小），如果是则直接返回。</span></span><br><span class="line">        tiny_mag_ptr-&gt;mag_last_free = NULL;</span><br><span class="line">        tiny_mag_ptr-&gt;mag_last_free_msize = <span class="number">0</span>;</span><br><span class="line">        tiny_mag_ptr-&gt;mag_last_free_rgn = NULL;</span><br><span class="line">        SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);</span><br><span class="line">        CHECK(szone, __PRETTY_FUNCTION__);</span><br><span class="line">        <span class="keyword">if</span> (cleared_requested) &#123;</span><br><span class="line">            memset(ptr, <span class="number">0</span>, TINY_BYTES_FOR_MSIZE(msize));</span><br><span class="line">        &#125;</span><br><span class="line">#if DEBUG_MALLOC</span><br><span class="line">        <span class="keyword">if</span> (LOG(szone, ptr)) &#123;</span><br><span class="line">            malloc_report(ASL_LEVEL_INFO, <span class="string">"in tiny_malloc_should_clear(), tiny cache ptr=%p, msize=%d\n"</span>, ptr, msize);</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">#endif /* CONFIG_TINY_CACHE */</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//先从freelist 查找</span></span><br><span class="line">        ptr = tiny_malloc_from_free_list(rack, tiny_mag_ptr, mag_index, msize);</span><br><span class="line">        <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);</span><br><span class="line">            CHECK(szone, __PRETTY_FUNCTION__);</span><br><span class="line">            <span class="keyword">if</span> (cleared_requested) &#123;</span><br><span class="line">                memset(ptr, <span class="number">0</span>, TINY_BYTES_FOR_MSIZE(msize));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从一个后备magazine中取出一个可用region，完整地拿过来放到当前magazine，再走一遍上面的步骤。</span></span><br><span class="line">        <span class="keyword">if</span> (tiny_get_region_from_depot(rack, tiny_mag_ptr, mag_index, msize)) &#123;</span><br><span class="line">            <span class="comment">//再次尝试从freelist 中获取</span></span><br><span class="line">            ptr = tiny_malloc_from_free_list(rack, tiny_mag_ptr, mag_index, msize);</span><br><span class="line">            <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">                SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);</span><br><span class="line">                CHECK(szone, __PRETTY_FUNCTION__);</span><br><span class="line">                <span class="keyword">if</span> (cleared_requested) &#123;</span><br><span class="line">                    memset(ptr, <span class="number">0</span>, TINY_BYTES_FOR_MSIZE(msize));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The magazine is exhausted. A new region (heap) must be allocated to satisfy this call to malloc().</span></span><br><span class="line">        <span class="comment">// The allocation, an mmap() system call, will be performed outside the magazine spin locks by the first</span></span><br><span class="line">        <span class="comment">// thread that suffers the exhaustion. That thread sets "alloc_underway" and enters a critical section.</span></span><br><span class="line">        <span class="comment">// Threads arriving here later are excluded from the critical section, yield the CPU, and then retry the</span></span><br><span class="line">        <span class="comment">// allocation. After some time the magazine is resupplied, the original thread leaves with its allocation,</span></span><br><span class="line">        <span class="comment">// and retry-ing threads succeed in the code just above.</span></span><br><span class="line">        <span class="keyword">if</span> (!tiny_mag_ptr-&gt;alloc_underway) &#123;</span><br><span class="line">            <span class="comment">//如果没有正在申请新的的 regin 操作，则进行申请操作</span></span><br><span class="line">            <span class="keyword">void</span> *fresh_region;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// time to create a new region (do this outside the magazine lock)</span></span><br><span class="line">            <span class="comment">//设置当前正在申请新的 堆</span></span><br><span class="line">            tiny_mag_ptr-&gt;alloc_underway = TRUE;</span><br><span class="line">            OSMemoryBarrier();</span><br><span class="line">            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);</span><br><span class="line">            <span class="comment">//申请新的堆                                 1m             </span></span><br><span class="line">            fresh_region = mvm_allocate_pages_securely(TINY_REGION_SIZE, TINY_BLOCKS_ALIGN, VM_MEMORY_MALLOC_TINY, rack-&gt;debug_flags);</span><br><span class="line">            SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// DTrace USDT Probe</span></span><br><span class="line">            MAGMALLOC_ALLOCREGION(TINY_SZONE_FROM_RACK(rack), (int)mag_index, fresh_region, TINY_REGION_SIZE);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!fresh_region) &#123; <span class="comment">// out of memory!</span></span><br><span class="line">                tiny_mag_ptr-&gt;alloc_underway = FALSE;</span><br><span class="line">                OSMemoryBarrier();</span><br><span class="line">                SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);</span><br><span class="line">                <span class="keyword">return</span> NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从最近的一个 region 或者新申请的 region中malloc</span></span><br><span class="line">            ptr = tiny_malloc_from_region_no_lock(rack, tiny_mag_ptr, mag_index, msize, fresh_region);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// we don't clear because this freshly allocated space is pristine</span></span><br><span class="line">            tiny_mag_ptr-&gt;alloc_underway = FALSE;</span><br><span class="line">            OSMemoryBarrier();</span><br><span class="line">            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);</span><br><span class="line">            CHECK(szone, __PRETTY_FUNCTION__);</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);</span><br><span class="line">            <span class="keyword">yield</span>();</span><br><span class="line">            SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* NOTREACHED */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次调用<code>free</code>函数，会直接把要释放的内存优先放到<code>mag_last_free</code>指针上，在下次alloc时，也会优先检查<code>mag_last_free</code> 是否存在大小相等的内存，如果存在就直接返回。</p>
<h4 id="tiny-malloc-from-free-list"><a href="#tiny-malloc-from-free-list" class="headerlink" title="tiny_malloc_from_free_list"></a>tiny_malloc_from_free_list</h4><p>这个函数的作用是从 free_list中不断进行各种策略尝试。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">tiny_malloc_from_free_list(rack_t *rack, magazine_t *tiny_mag_ptr, mag_index_t mag_index, msize_t msize)</span><br><span class="line">&#123;</span><br><span class="line">    tiny_free_list_t *ptr;</span><br><span class="line">    msize_t this_msize;</span><br><span class="line">    grain_t slot = tiny_slot_from_msize(msize);</span><br><span class="line">    <span class="comment">// free list 的首地址(第一个元素的地址)</span></span><br><span class="line">    free_list_t *free_list = tiny_mag_ptr-&gt;mag_free_list;</span><br><span class="line">    <span class="comment">// 在首地址基础上偏移 slot 个元素。相当于free_list[slot]</span></span><br><span class="line">    free_list_t *the_slot = free_list + slot;</span><br><span class="line">    tiny_free_list_t *next;</span><br><span class="line">    free_list_t *limit;</span><br><span class="line">#if defined(__LP64__)</span><br><span class="line">    uint64_t bitmap;</span><br><span class="line">#else</span><br><span class="line">    uint32_t bitmap;</span><br><span class="line">#endif</span><br><span class="line">    msize_t leftover_msize;</span><br><span class="line">    tiny_free_list_t *leftover_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assumes we've locked the region</span></span><br><span class="line">    CHECK_MAGAZINE_PTR_LOCKED(szone, tiny_mag_ptr, __PRETTY_FUNCTION__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Look for an exact match by checking the freelist for this msize.</span></span><br><span class="line">    <span class="comment">//策略1.</span></span><br><span class="line">    <span class="comment">//查找free list中当前请求大小区块的空闲缓存列表，如果有返回，并整理列表。</span></span><br><span class="line">    ptr = the_slot-&gt;p;</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        next = free_list_unchecksum_ptr(rack, &amp;ptr-&gt;next);</span><br><span class="line">        <span class="keyword">if</span> (next) &#123;</span><br><span class="line">            next-&gt;previous = ptr-&gt;previous;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BITMAPV_CLR(tiny_mag_ptr-&gt;mag_bitmap, slot);</span><br><span class="line">        &#125;</span><br><span class="line">        the_slot-&gt;p = next;</span><br><span class="line">        this_msize = msize;</span><br><span class="line">#if DEBUG_MALLOC</span><br><span class="line">        <span class="keyword">if</span> (LOG(szone, ptr)) &#123;</span><br><span class="line">            malloc_report(ASL_LEVEL_INFO, <span class="string">"in tiny_malloc_from_free_list(), exact match ptr=%p, this_msize=%d\n"</span>, ptr, this_msize);</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        goto return_tiny_alloc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mask off the bits representing slots holding free blocks smaller than the</span></span><br><span class="line">    <span class="comment">// size we need.  If there are no larger free blocks, try allocating from</span></span><br><span class="line">    <span class="comment">// the free space at the end of the tiny region.</span></span><br><span class="line">#if defined(__LP64__)</span><br><span class="line">    bitmap = ((uint64_t *)(tiny_mag_ptr-&gt;mag_bitmap))[<span class="number">0</span>] &amp; ~((<span class="number">1</span>ULL &lt;&lt; slot) - <span class="number">1</span>);</span><br><span class="line">#else</span><br><span class="line">    bitmap = tiny_mag_ptr-&gt;mag_bitmap[<span class="number">0</span>] &amp; ~((<span class="number">1</span> &lt;&lt; slot) - <span class="number">1</span>);</span><br><span class="line">#endif</span><br><span class="line">    <span class="keyword">if</span> (!bitmap) &#123;</span><br><span class="line">        goto try_tiny_malloc_from_end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    slot = BITMAPV_CTZ(bitmap);</span><br><span class="line">    limit = free_list + NUM_TINY_SLOTS;</span><br><span class="line">    free_list += slot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (free_list &lt; limit) &#123;</span><br><span class="line">        ptr = free_list-&gt;p;</span><br><span class="line">        <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">            next = free_list_unchecksum_ptr(rack, &amp;ptr-&gt;next);</span><br><span class="line">            free_list-&gt;p = next;</span><br><span class="line">            <span class="keyword">if</span> (next) &#123;</span><br><span class="line">                next-&gt;previous = ptr-&gt;previous;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                BITMAPV_CLR(tiny_mag_ptr-&gt;mag_bitmap, slot);</span><br><span class="line">            &#125;</span><br><span class="line">            this_msize = get_tiny_free_size(ptr);</span><br><span class="line">            goto add_leftover_and_proceed;</span><br><span class="line">        &#125;</span><br><span class="line">#if DEBUG_MALLOC</span><br><span class="line">        malloc_report(ASL_LEVEL_ERR, <span class="string">"in tiny_malloc_from_free_list(), mag_bitmap out of sync, slot=%d\n"</span>, slot);</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are now looking at the last slot, which contains blocks equal to, or</span></span><br><span class="line">    <span class="comment">// due to coalescing of free blocks, larger than NUM_TINY_SLOTS * tiny quantum size.</span></span><br><span class="line">    <span class="comment">// If the last freelist is not empty, and the head contains a block that is</span></span><br><span class="line">    <span class="comment">// larger than our request, then the remainder is put back on the free list.</span></span><br><span class="line">    ptr = limit-&gt;p;</span><br><span class="line">    <span class="comment">//策略2.</span></span><br><span class="line">    <span class="comment">//在free list找比当前申请区块大的，而且最接近的缓存，如果有返回，并把剩余大小放到free list中另外的链表上。</span></span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        <span class="comment">//获取一个比申请的size 大的</span></span><br><span class="line">        this_msize = get_tiny_free_size(ptr);</span><br><span class="line">        next = free_list_unchecksum_ptr(rack, &amp;ptr-&gt;next);</span><br><span class="line">        <span class="keyword">if</span> (this_msize - msize &gt; NUM_TINY_SLOTS) &#123;</span><br><span class="line">            <span class="comment">// the leftover will go back to the free list, so we optimize by</span></span><br><span class="line">            <span class="comment">// modifying the free list rather than a pop and push of the head</span></span><br><span class="line">            leftover_msize = this_msize - msize;</span><br><span class="line">            leftover_ptr = (tiny_free_list_t *)((unsigned char *)ptr + TINY_BYTES_FOR_MSIZE(msize));</span><br><span class="line">            limit-&gt;p = leftover_ptr;</span><br><span class="line">            <span class="keyword">if</span> (next) &#123;</span><br><span class="line">                next-&gt;previous.u = free_list_checksum_ptr(rack, leftover_ptr);</span><br><span class="line">            &#125;</span><br><span class="line">            leftover_ptr-&gt;previous = ptr-&gt;previous;</span><br><span class="line">            leftover_ptr-&gt;next = ptr-&gt;next;</span><br><span class="line">            <span class="comment">//把多余的size 重新放回freelist</span></span><br><span class="line">            set_tiny_meta_header_free(leftover_ptr, leftover_msize);</span><br><span class="line">#if DEBUG_MALLOC</span><br><span class="line">            <span class="keyword">if</span> (LOG(szone, ptr)) &#123;</span><br><span class="line">                malloc_report(ASL_LEVEL_INFO,</span><br><span class="line">                              <span class="string">"in tiny_malloc_from_free_list(), last slot ptr=%p, msize=%d this_msize=%d\n"</span>, ptr, msize, this_msize);</span><br><span class="line">            &#125;</span><br><span class="line">#endif</span><br><span class="line">            this_msize = msize;</span><br><span class="line">            goto return_tiny_alloc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next) &#123;</span><br><span class="line">            next-&gt;previous = ptr-&gt;previous;</span><br><span class="line">        &#125;</span><br><span class="line">        limit-&gt;p = next;</span><br><span class="line">        goto add_leftover_and_proceed;</span><br><span class="line">        <span class="comment">/* NOTREACHED */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">try_tiny_malloc_from_end:</span><br><span class="line">    <span class="comment">// Let's see if we can use tiny_mag_ptr-&gt;mag_bytes_free_at_end</span></span><br><span class="line">    <span class="comment">//策略3.</span></span><br><span class="line">    <span class="comment">//尝试在最后一个 region 开辟内存</span></span><br><span class="line">    <span class="keyword">if</span> (tiny_mag_ptr-&gt;mag_bytes_free_at_end &gt;= TINY_BYTES_FOR_MSIZE(msize)) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        uintptr_t tendptr = (uintptr_t)TINY_REGION_END(tiny_mag_ptr-&gt;mag_last_region);</span><br><span class="line">        ptr = (tiny_free_list_t *)(tendptr - tiny_mag_ptr-&gt;mag_bytes_free_at_end);</span><br><span class="line">        <span class="comment">//更新最后一个region 没有使用的size 16的倍数</span></span><br><span class="line">        tiny_mag_ptr-&gt;mag_bytes_free_at_end -= TINY_BYTES_FOR_MSIZE(msize);</span><br><span class="line">        <span class="keyword">if</span> (tiny_mag_ptr-&gt;mag_bytes_free_at_end) &#123;</span><br><span class="line">            <span class="comment">// let's add an in use block after ptr to serve as boundary</span></span><br><span class="line">            set_tiny_meta_header_in_use_1((unsigned char *)ptr + TINY_BYTES_FOR_MSIZE(msize));</span><br><span class="line">        &#125;</span><br><span class="line">        this_msize = msize;</span><br><span class="line">#if DEBUG_MALLOC</span><br><span class="line">        <span class="keyword">if</span> (LOG(szone, ptr)) &#123;</span><br><span class="line">            malloc_report(ASL_LEVEL_INFO, <span class="string">"in tiny_malloc_from_free_list(), from end ptr=%p, msize=%d\n"</span>, ptr, msize);</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        goto return_tiny_alloc;</span><br><span class="line">    &#125;</span><br><span class="line">#if CONFIG_ASLR_INTERNAL</span><br><span class="line">    <span class="comment">//策略4.</span></span><br><span class="line">    <span class="comment">//尝试在在第一个 region 开辟内存</span></span><br><span class="line">    <span class="comment">// Try from start if nothing left at end</span></span><br><span class="line">    <span class="keyword">if</span> (tiny_mag_ptr-&gt;mag_bytes_free_at_start &gt;= TINY_BYTES_FOR_MSIZE(msize)) &#123;</span><br><span class="line">        ptr = (tiny_free_list_t *)(TINY_REGION_ADDRESS(tiny_mag_ptr-&gt;mag_last_region) + tiny_mag_ptr-&gt;mag_bytes_free_at_start -</span><br><span class="line">                              TINY_BYTES_FOR_MSIZE(msize));</span><br><span class="line">        tiny_mag_ptr-&gt;mag_bytes_free_at_start -= TINY_BYTES_FOR_MSIZE(msize);</span><br><span class="line">        <span class="keyword">if</span> (tiny_mag_ptr-&gt;mag_bytes_free_at_start) &#123;</span><br><span class="line">            <span class="comment">// let's add an in use block before ptr to serve as boundary</span></span><br><span class="line">            set_tiny_meta_header_in_use_1((unsigned char *)ptr - TINY_QUANTUM);</span><br><span class="line">        &#125;</span><br><span class="line">        this_msize = msize;</span><br><span class="line">#if DEBUG_MALLOC</span><br><span class="line">        <span class="keyword">if</span> (LOG(szone, ptr)) &#123;</span><br><span class="line">            malloc_report(ASL_LEVEL_INFO, <span class="string">"in tiny_malloc_from_free_list(), from start ptr=%p, msize=%d\n"</span>, ptr, msize);</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        goto return_tiny_alloc;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    <span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">add_leftover_and_proceed:</span><br><span class="line">    <span class="keyword">if</span> (!this_msize || (this_msize &gt; msize)) &#123;</span><br><span class="line">        leftover_msize = this_msize - msize;</span><br><span class="line">        leftover_ptr = (tiny_free_list_t *)((unsigned char *)ptr + TINY_BYTES_FOR_MSIZE(msize));</span><br><span class="line">#if DEBUG_MALLOC</span><br><span class="line">        <span class="keyword">if</span> (LOG(szone, ptr)) &#123;</span><br><span class="line">            malloc_report(ASL_LEVEL_INFO, <span class="string">"in tiny_malloc_from_free_list(), adding leftover ptr=%p, this_msize=%d\n"</span>, ptr, this_msize);</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        tiny_free_list_add_ptr(rack, tiny_mag_ptr, leftover_ptr, leftover_msize);</span><br><span class="line">        this_msize = msize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">return_tiny_alloc:</span><br><span class="line">    tiny_mag_ptr-&gt;mag_num_objects++;</span><br><span class="line">    tiny_mag_ptr-&gt;mag_num_bytes_in_objects += TINY_BYTES_FOR_MSIZE(this_msize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update this region's bytes in use count</span></span><br><span class="line">    <span class="comment">//根据ptr换算出node</span></span><br><span class="line">    region_trailer_t *node = REGION_TRAILER_FOR_TINY_REGION(TINY_REGION_FOR_PTR(ptr));</span><br><span class="line">    size_t bytes_used = node-&gt;bytes_used + TINY_BYTES_FOR_MSIZE(this_msize);</span><br><span class="line">    node-&gt;bytes_used = (unsigned int)bytes_used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emptiness discriminant</span></span><br><span class="line">    <span class="keyword">if</span> (bytes_used &lt; DENSITY_THRESHOLD(TINY_REGION_PAYLOAD_BYTES)) &#123;</span><br><span class="line">        <span class="comment">/* After this allocation the region is still sparse, so it must have been even more so before</span></span><br><span class="line"><span class="comment">         * the allocation. That implies the region is already correctly marked. Do nothing. */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Region has crossed threshold from sparsity to density. Mark it not "suitable" on the</span></span><br><span class="line"><span class="comment">         * recirculation candidates list. */</span></span><br><span class="line">        node-&gt;recirc_suitable = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">#if DEBUG_MALLOC</span><br><span class="line">    <span class="keyword">if</span> (LOG(szone, ptr)) &#123;</span><br><span class="line">        malloc_report(ASL_LEVEL_INFO, <span class="string">"in tiny_malloc_from_free_list(), ptr=%p, this_msize=%d, msize=%d\n"</span>, ptr, this_msize, msize);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    <span class="keyword">if</span> (this_msize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        set_tiny_meta_header_in_use(ptr, this_msize);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        set_tiny_meta_header_in_use_1(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的流程可以看出，在查找已经释放的内存缓存，会采用2步缓存查找(策略1，2)，及两步备用内存的开辟(策略3，4)。<br>当free_list流程仍然找不到可以使用内存，就会使用<code>tiny_get_region_from_depot</code></p>
<h4 id="tiny-get-region-from-depot"><a href="#tiny-get-region-from-depot" class="headerlink" title="tiny_get_region_from_depot"></a>tiny_get_region_from_depot</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> boolean_t</span><br><span class="line">tiny_get_region_from_depot(rack_t *rack, magazine_t *tiny_mag_ptr, mag_index_t mag_index, msize_t msize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//index为-1的magazine作为后备之用</span></span><br><span class="line">    magazine_t *depot_ptr = &amp;(rack-&gt;magazines[DEPOT_MAGAZINE_INDEX]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* <span class="doctag">FIXME:</span> Would Uniprocessor benefit from recirc and MADV_FREE? */</span></span><br><span class="line">    <span class="keyword">if</span> (rack-&gt;num_magazines == <span class="number">1</span>) &#123; <span class="comment">// Uniprocessor, single magazine, so no recirculation necessary</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if DEBUG_MALLOC</span><br><span class="line">    <span class="keyword">if</span> (DEPOT_MAGAZINE_INDEX == mag_index) &#123;</span><br><span class="line">        malloc_zone_error(rack-&gt;debug_flags, <span class="literal">true</span>, <span class="string">"tiny_get_region_from_depot called for magazine index -1\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    SZONE_MAGAZINE_PTR_LOCK(depot_ptr);</span><br><span class="line">    <span class="comment">//在备用的 region 里面找一个能满足 msize</span></span><br><span class="line">    <span class="comment">// Appropriate a Depot'd region that can satisfy requested msize.</span></span><br><span class="line">    region_trailer_t *node;</span><br><span class="line">    region_t sparse_region;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sparse_region = tiny_find_msize_region(rack, depot_ptr, DEPOT_MAGAZINE_INDEX, msize);</span><br><span class="line">        <span class="keyword">if</span> (NULL == sparse_region) &#123; <span class="comment">// Depot empty?</span></span><br><span class="line">            SZONE_MAGAZINE_PTR_UNLOCK(depot_ptr);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node = REGION_TRAILER_FOR_TINY_REGION(sparse_region);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &gt;= node-&gt;pinned_to_depot) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SZONE_MAGAZINE_PTR_UNLOCK(depot_ptr);</span><br><span class="line">        <span class="keyword">yield</span>();</span><br><span class="line">        SZONE_MAGAZINE_PTR_LOCK(depot_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这里，一定是找到了。</span></span><br><span class="line">    <span class="comment">//去掉node在备用 depot 的关联</span></span><br><span class="line">    <span class="comment">// disconnect node from Depot</span></span><br><span class="line">    </span><br><span class="line">    recirc_list_extract(rack, depot_ptr, node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate the region pulling its free entries off the (locked) Depot's free list</span></span><br><span class="line">    int objects_in_use = tiny_free_detach_region(rack, depot_ptr, sparse_region);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transfer ownership of the region</span></span><br><span class="line">    MAGAZINE_INDEX_FOR_TINY_REGION(sparse_region) = mag_index;</span><br><span class="line">    node-&gt;pinned_to_depot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate the region putting its free entries on its new (locked) magazine's free list</span></span><br><span class="line">    size_t bytes_inplay = tiny_free_reattach_region(rack, tiny_mag_ptr, sparse_region);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新对应的字段</span></span><br><span class="line">    depot_ptr-&gt;mag_num_bytes_in_objects -= bytes_inplay;</span><br><span class="line">    depot_ptr-&gt;num_bytes_in_magazine -= TINY_REGION_PAYLOAD_BYTES;</span><br><span class="line">    depot_ptr-&gt;mag_num_objects -= objects_in_use;</span><br><span class="line"></span><br><span class="line">    tiny_mag_ptr-&gt;mag_num_bytes_in_objects += bytes_inplay;</span><br><span class="line">    tiny_mag_ptr-&gt;num_bytes_in_magazine += TINY_REGION_PAYLOAD_BYTES;</span><br><span class="line">    tiny_mag_ptr-&gt;mag_num_objects += objects_in_use;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// connect to magazine as first node</span></span><br><span class="line">    <span class="comment">//关联到当前的magazine_t</span></span><br><span class="line">    recirc_list_splice_first(rack, tiny_mag_ptr, node);</span><br><span class="line"></span><br><span class="line">    SZONE_MAGAZINE_PTR_UNLOCK(depot_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DTrace USDT Probe</span></span><br><span class="line">    MAGMALLOC_DEPOTREGION(TINY_SZONE_FROM_RACK(rack), (int)mag_index, (<span class="keyword">void</span> *)sparse_region,</span><br><span class="line">            TINY_REGION_SIZE, (int)BYTES_USED_FOR_TINY_REGION(sparse_region));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个类型的<code>rack</code>指向的<code>magazines</code>，都会在下标为-1<code>magazine_t</code>当做备用：depot，该方法的作用是从备用的<code>depot</code>查找出是否有满足条件的<code>region</code>如果存在，更新<code>depot</code>和<code>region</code>的关联关系，然后在关联当前的<code>magazine_t</code>和<code>region</code>。之后在再次重复<code>free_list</code>过程。</p>
<h4 id="mvm-allocate-pages-securely"><a href="#mvm-allocate-pages-securely" class="headerlink" title="mvm_allocate_pages_securely"></a>mvm_allocate_pages_securely</h4><p>走到这一步，就需要申请新的heap了，这里需要理解虚拟内存和物理内存的映射关系。<br>你其实只要记住两点：<code>vm_map</code>代表就是一个进程运行时候涉及的虚拟内存，<code>pmap</code>代表的就是和具体硬件架构相关的物理内存。<br>重新申请的核心函数为<code>mach_vm_map</code>,其概念如图<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/libmalloc/532E4275-3240-4ED8-A070-5CB1B6352E01.png" alt="img"></p>
<h4 id="tiny-malloc-from-region-no-lock"><a href="#tiny-malloc-from-region-no-lock" class="headerlink" title="tiny_malloc_from_region_no_lock"></a>tiny_malloc_from_region_no_lock</h4><p>重新申请了新的内存(region)之后，挂载到当前的magazine下并分配内存。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">tiny_malloc_from_region_no_lock(rack_t *rack,</span><br><span class="line">                                magazine_t *tiny_mag_ptr,</span><br><span class="line">                                mag_index_t mag_index,</span><br><span class="line">                                msize_t msize,</span><br><span class="line">                                <span class="keyword">void</span> *aligned_address)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deal with unclaimed memory -- mag_bytes_free_at_end or mag_bytes_free_at_start</span></span><br><span class="line">    <span class="keyword">if</span> (tiny_mag_ptr-&gt;mag_bytes_free_at_end || tiny_mag_ptr-&gt;mag_bytes_free_at_start) &#123;</span><br><span class="line">        tiny_finalize_region(rack, tiny_mag_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We set the unused bits of the header in the last pair to be all ones, and those of the inuse to zeroes.</span></span><br><span class="line">#if NUM_TINY_BLOCKS &amp; 31</span><br><span class="line">    <span class="keyword">const</span> uint32_t header = <span class="number">0xFFFFFFFF</span>U &lt;&lt; (NUM_TINY_BLOCKS &amp; <span class="number">31</span>);</span><br><span class="line">#else</span><br><span class="line">    <span class="keyword">const</span> uint32_t header = <span class="number">0</span>;</span><br><span class="line">#endif </span><br><span class="line">    <span class="comment">//把新申请的内存地址转化为 region</span></span><br><span class="line">    tiny_region_t trt = (tiny_region_t)aligned_address;</span><br><span class="line">    ((tiny_region_t)aligned_address)-&gt;pairs[CEIL_NUM_TINY_BLOCKS_WORDS - <span class="number">1</span>].header = header;</span><br><span class="line">    ((tiny_region_t)aligned_address)-&gt;pairs[CEIL_NUM_TINY_BLOCKS_WORDS - <span class="number">1</span>].inuse = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tag the region at "aligned_address" as belonging to us,</span></span><br><span class="line">    <span class="comment">// and so put it under the protection of the magazine lock we are holding.</span></span><br><span class="line">    <span class="comment">// Do this before advertising "aligned_address" on the hash ring(!)</span></span><br><span class="line">    <span class="comment">//把region 的地址和当前的mag_index 关联起来，因为在calloc时，就是要根据不同的index 获取magazine，</span></span><br><span class="line">    <span class="comment">//在根据magazine拿到关联的 region</span></span><br><span class="line">    MAGAZINE_INDEX_FOR_TINY_REGION(aligned_address) = mag_index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert the new region into the hash ring</span></span><br><span class="line">    rack_region_insert(rack, (region_t)aligned_address);</span><br><span class="line"></span><br><span class="line">    tiny_mag_ptr-&gt;mag_last_region = aligned_address;</span><br><span class="line">    BYTES_USED_FOR_TINY_REGION(aligned_address) = TINY_BYTES_FOR_MSIZE(msize);</span><br><span class="line"></span><br><span class="line">#if CONFIG_ASLR_INTERNAL</span><br><span class="line">    int offset_msize = malloc_entropy[<span class="number">0</span>] &amp; TINY_ENTROPY_MASK;</span><br><span class="line">#if DEBUG_MALLOC</span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">"MallocASLRForce"</span>)) &#123;</span><br><span class="line">        offset_msize = strtol(getenv(<span class="string">"MallocASLRForce"</span>), NULL, <span class="number">0</span>) &amp; TINY_ENTROPY_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">"MallocASLRPrint"</span>)) &#123;</span><br><span class="line">        malloc_report(ASL_LEVEL_INFO, <span class="string">"Region: %p offset: %d\n"</span>, aligned_address, offset_msize);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">#else</span><br><span class="line">    int offset_msize = <span class="number">0</span>;</span><br><span class="line">#endif</span><br><span class="line">    uintptr_t ads = (uintptr_t)aligned_address;</span><br><span class="line">    uintptr_t om = TINY_BYTES_FOR_MSIZE(offset_msize);</span><br><span class="line">    ptr = (<span class="keyword">void</span> *)(ads + om);</span><br><span class="line">    set_tiny_meta_header_in_use(ptr, msize);</span><br><span class="line">    <span class="comment">//更新当前magazine 的相关信息</span></span><br><span class="line">    tiny_mag_ptr-&gt;mag_num_objects++;</span><br><span class="line">    tiny_mag_ptr-&gt;mag_num_bytes_in_objects += TINY_BYTES_FOR_MSIZE(msize);</span><br><span class="line">    tiny_mag_ptr-&gt;num_bytes_in_magazine += TINY_REGION_PAYLOAD_BYTES;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We put a header on the last block so that it appears in use (for coalescing, etc...)</span></span><br><span class="line">    set_tiny_meta_header_in_use_1((<span class="keyword">void</span> *)((uintptr_t)ptr + TINY_BYTES_FOR_MSIZE(msize)));</span><br><span class="line">    tiny_mag_ptr-&gt;mag_bytes_free_at_end = TINY_BYTES_FOR_MSIZE(NUM_TINY_BLOCKS - msize - offset_msize);</span><br><span class="line"></span><br><span class="line">#if CONFIG_ASLR_INTERNAL</span><br><span class="line">    <span class="comment">// Put a header on the previous block for same reason</span></span><br><span class="line">    tiny_mag_ptr-&gt;mag_bytes_free_at_start = TINY_BYTES_FOR_MSIZE(offset_msize);</span><br><span class="line">    <span class="keyword">if</span> (offset_msize) &#123;</span><br><span class="line">        set_tiny_meta_header_in_use_1((<span class="keyword">void</span> *)((uintptr_t)ptr - TINY_QUANTUM));</span><br><span class="line">    &#125;</span><br><span class="line">#else</span><br><span class="line">    tiny_mag_ptr-&gt;mag_bytes_free_at_start = <span class="number">0</span>;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    <span class="comment">// connect to magazine as last node</span></span><br><span class="line">    <span class="comment">//关联到magazine</span></span><br><span class="line">    recirc_list_splice_last(rack, tiny_mag_ptr, REGION_TRAILER_FOR_TINY_REGION(aligned_address));</span><br><span class="line"></span><br><span class="line">#if DEBUG_MALLOC</span><br><span class="line">    <span class="keyword">if</span> (LOG(szone, ptr)) &#123;</span><br><span class="line">        malloc_report(ASL_LEVEL_INFO, <span class="string">"in tiny_malloc_from_region_no_lock(), ptr=%p, msize=%d\n"</span>, ptr, msize);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法的主要作用是把新申请的内存地址，转换为region，并进行相关的关联。及更新对应的magazine。整个scalable_zone的结构体关系，及流程如下<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/libmalloc/WeChatd6deae28d03f7b6849ac37a36dbab22f.png" alt="img"></p>
<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>对于free操作同样会选择对应的zone 进行</p>
<h3 id="nano-zone"><a href="#nano-zone" class="headerlink" title="nano_zone"></a>nano_zone</h3><p>malloc库会检查指针地址，如果没有问题，则以链表的形式将这些区块按大小存储起来。这些链表的头部放在meta_data数组中对应的[mag][slot]元素中。<br>其实从缓存获取空余内存和释放内存时都会对指向这篇内存区域的指针进行检查，如果有类似地址不对齐、未释放/多次释放、所属地址与预期的mag、slot不匹配等情况都会以报错结束。</p>
<h3 id="scalable-zone"><a href="#scalable-zone" class="headerlink" title="scalable_zone"></a>scalable_zone</h3><p>首先检查指针指向地址是否有问题。<br>如果last free指针上没有挂载内存区块，则放到last free上。<br>如果有last free，置换内存，并把last free原有内存区块挂载到free list上（在挂载的free list前，会先根据region位图检查前后区块是否能合并成更大区块，如果能会合并成一个）。<br>合并后所在的region如果空闲字节超过一定条件，则将把此region放到后备的magazine中（-1）。<br>如果整个region都是空的，则直接还给系统内核。</p>
<h2 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h2><p><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/libmalloc/8FB7E08B35EE88A4B0FEEC6C565CE1DA.png" alt="img"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p><code>malloc_zone_t</code>提供了一个模板类，或者理解为<code>malloc_zone_t</code>提供一类接口（高度抽象了alloc一个对象所需要的特征），free，calloc等。<br>由所有拓展的结构体来实现真正的目标函数。<br>同上对于上层Objc，提供了抽象接口(依赖倒置),这样就降低了调用者(Objc)与实现模块间的耦合。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/libmalloc/" rel="tag"># libmalloc</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/03/静态链接/" rel="next" title="静态链接">
                <i class="fa fa-chevron-left"></i> 静态链接
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/29/2019年度总结/" rel="prev" title="2019年度总结">
                2019年度总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/profile/avatar.png" alt="yfeii">
            
              <p class="site-author-name" itemprop="name">yfeii</p>
              <div class="site-description motion-element" itemprop="description">邮箱1486662452@qq.com，有问题欢迎留言评论或邮件。</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc-zone-t"><span class="nav-number">2.</span> <span class="nav-text">malloc_zone_t</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#calloc"><span class="nav-number">3.</span> <span class="nav-text">calloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#default-zone-引导"><span class="nav-number">4.</span> <span class="nav-text">default_zone 引导</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zone"><span class="nav-number">5.</span> <span class="nav-text">zone</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#nanozone-t"><span class="nav-number">5.1.</span> <span class="nav-text">nanozone_t</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#nano-create-zone"><span class="nav-number">5.1.1.</span> <span class="nav-text">nano_create_zone</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nano-calloc"><span class="nav-number">5.1.2.</span> <span class="nav-text">nano_calloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nano-malloc-check-clear"><span class="nav-number">5.1.3.</span> <span class="nav-text">_nano_malloc_check_clear</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#segregated-next-block"><span class="nav-number">5.1.4.</span> <span class="nav-text">segregated_next_block</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#segregated-band-grow"><span class="nav-number">5.1.5.</span> <span class="nav-text">segregated_band_grow</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scalable-zone-helper-zone"><span class="nav-number">5.2.</span> <span class="nav-text">scalable zone(helper_zone)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#szone-malloc-should-clear"><span class="nav-number">5.2.1.</span> <span class="nav-text">szone_malloc_should_clear</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tiny-malloc-should-clear"><span class="nav-number">5.2.2.</span> <span class="nav-text">tiny_malloc_should_clear</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tiny-malloc-from-free-list"><span class="nav-number">5.2.3.</span> <span class="nav-text">tiny_malloc_from_free_list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tiny-get-region-from-depot"><span class="nav-number">5.2.4.</span> <span class="nav-text">tiny_get_region_from_depot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mvm-allocate-pages-securely"><span class="nav-number">5.2.5.</span> <span class="nav-text">mvm_allocate_pages_securely</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tiny-malloc-from-region-no-lock"><span class="nav-number">5.2.6.</span> <span class="nav-text">tiny_malloc_from_region_no_lock</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#free"><span class="nav-number">6.</span> <span class="nav-text">free</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#nano-zone"><span class="nav-number">6.1.</span> <span class="nav-text">nano_zone</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scalable-zone"><span class="nav-number">6.2.</span> <span class="nav-text">scalable_zone</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流程总结"><span class="nav-number">7.</span> <span class="nav-text">流程总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">8.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设计"><span class="nav-number">8.1.</span> <span class="nav-text">设计</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yfeii</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/affix.js?v=7.1.1"></script>

  <script src="/js/schemes/pisces.js?v=7.1.1"></script>



  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  
  
  <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>


<script>
  var disqus_config = function() {
    this.page.url = "http://yfeii.github.io/2019/12/18/缘起alloc/";
    this.page.identifier = "2019/12/18/缘起alloc/";
    this.page.title = '缘起alloc';
    };
  function loadComments() {
    var d = document, s = d.createElement('script');
    s.src = 'https://.disqus.com/embed.js';
    s.setAttribute('data-timestamp', '' + +new Date());
    (d.head || d.body).appendChild(s);
  }
  
    $(function() {
      var offsetTop = $('#comments').offset().top - $(window).height();
      if (offsetTop <= 0) {
        // load directly when there's no a scrollbar
        loadComments();
      } else {
        $(window).on('scroll.disqus_scroll', function() {
          // offsetTop may changes because of manually resizing browser window or lazy loading images.
          var offsetTop = $('#comments').offset().top - $(window).height();
          var scrollTop = $(window).scrollTop();

          // pre-load comments a bit? (margin or anything else)
          if (offsetTop - scrollTop < 60) {
            $(window).off('.disqus_scroll');
            loadComments();
          }
        });
      }
    });
  
</script>





  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>

<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="用这篇文章来结束 Objective-C的底层总结。">
<meta name="keywords" content="底层">
<meta property="og:type" content="article">
<meta property="og:title" content="Objective-C底层汇总">
<meta property="og:url" content="http://yfeii.github.io/2019/12/30/Objective-C底层汇总/index.html">
<meta property="og:site_name" content="逆水行舟">
<meta property="og:description" content="用这篇文章来结束 Objective-C的底层总结。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/F25C37F5-1D05-4087-9867-DEFE6D237C53.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/5D0CC956-B300-4CDB-BD50-53C07B712C10.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/AEC188A7-3E8A-42C6-9336-4D089A643DD8.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/28EBCE85-040D-4030-A18B-D967A6DB2055.jpg">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/D2979820-1B14-4624-AEA8-AD080DBE7EA8.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/objc_class.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/742D0229-49F9-492B-B492-4D49E19A40C4.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/94BACBE3-2A25-42E5-9DB7-E80D5CE7B772.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/2F9B5925-AEFC-4C0D-BAE0-13A1ED7B0EA5.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/F7D3F61B-539B-423A-A3B4-0AE95CAE0D45.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/F7D3F61B-539B-423A-A3B4-0AE95CAE0D45.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/cache_t.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/9417849E-AED4-419F-A4E9-B9C105BEC2BA.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/5C93DDAA-4939-4694-B13C-2A763B913192.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/F82FD932-55BD-4192-9696-EA867FF8071A.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/BC67DB9F-2DA5-46E4-AB43-873589F409F8.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/E444A701-A9A9-4A92-A0A4-B91127730270.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/437FAD4A-1FEA-4CDA-AC3E-A258E1EE64C8.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/F201FDF1-7660-4E55-9DC5-E4B3BE6AC421.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/AEE7605B-A5FF-4214-AE73-27FC3B720155.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/75BB4990-0654-4F77-867B-EEFD1F725D50.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/06D2A0A7-AC2A-4006-8E57-2C2FEAC61816.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/msgSend.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/forward.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/01F0F5A1-C5C7-49A2-BA68-4802D5884A8B.png">
<meta property="og:updated_time" content="2020-02-11T07:41:13.350Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Objective-C底层汇总">
<meta name="twitter:description" content="用这篇文章来结束 Objective-C的底层总结。">
<meta name="twitter:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/F25C37F5-1D05-4087-9867-DEFE6D237C53.png">





  
  
  <link rel="canonical" href="http://yfeii.github.io/2019/12/30/Objective-C底层汇总/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Objective-C底层汇总 | 逆水行舟</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逆水行舟</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yfeii.github.io/2019/12/30/Objective-C底层汇总/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yfeii">
      <meta itemprop="description" content="邮箱1486662452@qq.com，有问题欢迎留言评论或邮件">
      <meta itemprop="image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/profile/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逆水行舟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Objective-C底层汇总

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-30 22:58:40" itemprop="dateCreated datePublished" datetime="2019-12-30T22:58:40+08:00">2019-12-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-11 15:41:13" itemprop="dateModified" datetime="2020-02-11T15:41:13+08:00">2020-02-11</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>用这篇文章来结束<code> Objective-C</code>的底层总结。<a id="more"></a><br>既然是底层，那么一定是需要一定的<code>Objective-C</code>编程基础，阅读本文的前提，</p>
<blockquote>
<p>知晓对象，类对象，元类(只要知道概念就好)<br>知晓类是struct(同样有概念就好)      </p>
</blockquote>
<p>本文所使用的<code>runtime</code>版本为756.2。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>Objective-C是C语言的严格超集－－任何C语言程序不经修改就可以直接通过Objective-C编译器，在Objective-C中使用C语言代码也是完全合法的。Objective-C的面向对象语法源于Smalltalk消息传递风格。<br>通过这句话，我们可以得到两个信息：</p>
<ul>
<li>Objective-C是C语言的严格超集。</li>
<li>Objective-C的面向对象语法源于Smalltalk消息传递风格。  </li>
</ul>
</blockquote>
<p>那么我们来思考两个问题：</p>
<ul>
<li>如何使C语言实现一个 OOP 对象模型。</li>
<li>如何 Smalltalk 风格的 Message 机制。  </li>
</ul>
<h2 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h2><p>我们平时使用的对象都是<code>id</code>类型定义的，都是<code>objc_object</code>这样的结构体，而后我们可以把<code>id</code>强转成其他任意的<code>class</code>类型，是因为<code>class</code>本质是<code>objc_class</code>结构体。而<code>objc_class</code>是继承<code>objc_object</code>的。也就是<code>里式替换原则</code></p>
<h3 id="objc-object"><a href="#objc-object" class="headerlink" title="objc_object"></a>objc_object</h3><p>那么<code>objc_object</code>里都放了些什么呢？<code>objc_object</code>结构体内部可以分为五个部分，如图。<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/F25C37F5-1D05-4087-9867-DEFE6D237C53.png" alt="img"><br>可以看出<code>objc_object</code>结构体主要提供了管理自身对象的一些接口，其中比较重要的就是<code>isa_t</code>结构了。</p>
<h4 id="isa-t"><a href="#isa-t" class="headerlink" title="isa_t"></a>isa_t</h4><p>下面来看一下<code>isa_t<code>的结构，其本质为联合体。以64位为例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line"><span class="comment">//isa 的两种初始化方法</span></span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"><span class="comment">//两种互斥类型的isa。</span></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">#if defined(ISA_BITFIELD)</span><br><span class="line">    struct &#123;</span><br><span class="line">        ISA_BITFIELD;  <span class="comment">// defined in isa.h</span></span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//64位CPU架构 bits 的定义如下</span></span><br><span class="line">uintptr_t nonpointer        : <span class="number">1</span>;     <span class="comment">//是否是指针类型</span></span><br><span class="line">uintptr_t has_assoc         : <span class="number">1</span>;     <span class="comment">//是否有关联对象</span></span><br><span class="line">uintptr_t has_cxx_dtor      : <span class="number">1</span>;     <span class="comment">//是否有C++相关的析构方法</span></span><br><span class="line">uintptr_t shiftcls          : <span class="number">44</span>;    <span class="comment">//class 的地址</span></span><br><span class="line">uintptr_t magic             : <span class="number">6</span>;     <span class="comment">//系统架构标识</span></span><br><span class="line">uintptr_t weakly_referenced : <span class="number">1</span>;     <span class="comment">//是否有弱引用</span></span><br><span class="line">uintptr_t deallocating      : <span class="number">1</span>;     <span class="comment">//是否正在释放</span></span><br><span class="line">uintptr_t has_sidetable_rc  : <span class="number">1</span>;     <span class="comment">//是否使用 SideTable 管理引用计数。当extra_rc 放不下时(2^8)使用</span></span><br><span class="line">uintptr_t extra_rc          : <span class="number">8</span>      <span class="comment">//引用计数</span></span><br></pre></td></tr></table></figure></code></code></p>
<p>联合体在公用内存的同时，其内部的成员也是内存互斥的，也就是说，如果<code>cls</code>存在，则<code>bits</code>不存在，反之相同。<br>因此<code>isa_t</code>有两种表现形式。一种为<code>class</code>的<code>cls</code>指针，另种为<code>bits</code>。其区别如下图<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/5D0CC956-B300-4CDB-BD50-53C07B712C10.png" alt="isa"><br>关于何时使用<code>指针</code>形式的<code>isa_t</code>，可以通过两个方面控制</p>
<ul>
<li>通过 Environment Variables 设置变量 OBJC_DISABLE_NONPOINTER_ISA 为 YES 或 NO</li>
<li>通过 class 的 flag 设置。(下文会说明)</li>
</ul>
<h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>下面我们通过<code>lldb</code>来证明下上面的结果。首先我们设置<code>OBJC_DISABLE_NONPOINTER_ISA</code>为<code>NO</code><br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/AEC188A7-3E8A-42C6-9336-4D089A643DD8.png" alt="isa"><br>我们先来获取<code>person</code>对象的class。分成如下几个步骤</p>
<ol>
<li>获取实例的 <code>isa</code></li>
<li>获取<code>isa </code>的二进制形式</li>
<li>根据<code>bits</code>的定义和<code>isa</code>的二进制，我们要取其中的44位(3~47)的值。  </li>
</ol>
<p>实际上在定义<code>bits</code>的地方同样定义了一些宏，称为<code>mask</code>，我们可以通过<code>&amp;</code>来获取相应的值。如图。<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/28EBCE85-040D-4030-A18B-D967A6DB2055.jpg" alt="img"><br>下我们把<code>OBJC_DISABLE_NONPOINTER_ISA</code>为<code>YES</code><br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/D2979820-1B14-4624-AEA8-AD080DBE7EA8.png" alt="img"></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>在最新的系统下(ios13或mac10.15下)对isa直接使用了指针类型，并未启用 指针优化，即使设置了<code>OBJC_DISABLE_NONPOINTER_ISA</code>也无效。</p>
<h3 id="objc-class"><a href="#objc-class" class="headerlink" title="objc_class"></a>objc_class</h3><p><code>objc_class</code>作为<code>objc_object</code>的子类，实现了把各个类(NSObject)串联(继承)到了一起，并为<code>runtime</code>提供了基石。<br>通过<code>objc_object</code>基类提供的接口我们发现，其实对象（实例）是没有能力来“调用”方法的，因为在<code>objc_object</code>的定义中并没有方法相关的结构。是<code>objc_class</code>赋予了对象调用方法的能力。也是由<code>objc_class</code>和<code>runtime</code>使得<code>Objective-C</code>具有了面向对象的能力<br><code>objc_object</code>结构体内部可以分为四个部分，如图。<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/objc_class.png" alt="img"></p>
<p>其中主要的结构为<code>cache_t</code>和<code>class_data_bits_t</code></p>
<h3 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h3><p><code>cache_t</code>是一种用来快速查找执行函数的一种机制。我们知道<code>Objective-C</code>为了实现其动态性，将函数地址的调用，包装成了<code>SEL</code>寻找<code>IMP</code>的过程 ,随之带来的负面影响就是降低了方法调用的效率，为了解决这一问题。<code>Objc</code>采用了方法缓存的机制来提高调用效率。<br><code>cache_t</code>的特点如下。  </p>
<ul>
<li>用于快速查找执行函数</li>
<li>是可增量扩容的哈希表结构</li>
<li>局部性原理的应用    </li>
</ul>
<p><code>cache_t</code>结构体的定义如下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    struct bucket_t *_buckets; <span class="comment">//缓存数组</span></span><br><span class="line">    mask_t _mask;              <span class="comment">//当前数组的需要扩容的临界值</span></span><br><span class="line">    mask_t _occupied;          <span class="comment">//数组的中被使用的容量</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="初步验证"><a href="#初步验证" class="headerlink" title="初步验证"></a>初步验证</h4><p>下面我们来借助<code>lldb</code>还原下上面的场景。<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/742D0229-49F9-492B-B492-4D49E19A40C4.png" alt="img"><br>我们将上面的代码执行<code>step over</code>。<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/94BACBE3-2A25-42E5-9DB7-E80D5CE7B772.png" alt="img"><br>通过上面的例子我们能验证缓存确实存在<code>bucket_t</code>中，还有<code>occupied</code>代码缓存已使用的数量，但是，我们也发现并不是在数组的第一位按顺序存储的，而且数组的大小及存储规则还不清楚,下面我们结合源码和<code>lldb</code>来验证。</p>
<ol>
<li>缓存如何命中。</li>
<li>buckets如何创建。</li>
<li>buckets如何管理缓存。   </li>
</ol>
<h4 id="cache-fill-nolock"><a href="#cache-fill-nolock" class="headerlink" title="cache_fill_nolock"></a>cache_fill_nolock</h4><p><code>cache_fill_nolock</code>是缓存体系提供给外部使用的api，主要服务于<code>msgSend</code>。通过调用方法，来触发<code>cache_fill_nolock</code>，此函数的作用为，查找，并填充缓存。<br>首先来看源码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Never cache before +initialize is done</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isInitialized()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the entry wasn't added to the cache by some other thread </span></span><br><span class="line">    <span class="comment">// before we grabbed the cacheUpdateLock.</span></span><br><span class="line">    <span class="keyword">if</span> (cache_getImp(cls, sel)) <span class="keyword">return</span>;</span><br><span class="line">   </span><br><span class="line">    cache_t *cache = getCache(cls);</span><br><span class="line">    <span class="comment">//SEL强转为 uintptr_t 类型的 无符号整形数字。</span></span><br><span class="line">    cache_key_t key = getKey(sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the cache as-is if it is less than 3/4 full</span></span><br><span class="line">    <span class="comment">//在已经使用数量的基础上+1，获得将要更新缓存之后的已使用数量</span></span><br><span class="line">    mask_t newOccupied = cache-&gt;occupied() + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//获取当前缓存的总容量 capacity = mask + 1</span></span><br><span class="line">    mask_t capacity = cache-&gt;capacity();</span><br><span class="line">    <span class="comment">//如果是空的缓存（occupied==0 &amp;&amp;  capacity==0）</span></span><br><span class="line">    <span class="keyword">if</span> (cache-&gt;isConstantEmptyCache()) &#123;</span><br><span class="line">        <span class="comment">// Cache is read-only. Replace it.</span></span><br><span class="line">        <span class="comment">// 重新开辟新的cache，第一次到这里capacity,mask = 0 所以使用 INIT_CACHE_SIZE，为4</span></span><br><span class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (newOccupied &lt;= capacity / <span class="number">4</span> * <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">//小于3/4 可以继续使用</span></span><br><span class="line">        <span class="comment">// Cache is less than 3/4 full. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Cache is too full. Expand it.</span></span><br><span class="line">        <span class="comment">// 超过3/4 要扩容</span></span><br><span class="line">        cache-&gt;expand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan for the first unused slot and insert there.</span></span><br><span class="line">    <span class="comment">// There is guaranteed to be an empty slot because the </span></span><br><span class="line">    <span class="comment">// minimum size is 4 and we resized at 3/4 full.</span></span><br><span class="line">    <span class="comment">//根据Key（SEL）查找cache</span></span><br><span class="line">    bucket_t *bucket = cache-&gt;find(key, receiver);</span><br><span class="line">    <span class="keyword">if</span> (bucket-&gt;key() == <span class="number">0</span>) cache-&gt;incrementOccupied();</span><br><span class="line">    bucket-&gt;<span class="keyword">set</span>(key, imp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到该方法的流程主要分为3个阶段。  </p>
<ol>
<li>通过<code>getKey</code>方法获取到一个正整型的<code>key</code>。  </li>
<li>缓存空间的判断策略(初始化，或者扩容，或者直接使用)。</li>
<li>通过<code>key</code>查找<code>bucket</code>。  </li>
</ol>
<p>第一个阶段比较简单，就是通过类型转换来得到<code>key</code>。我们来看第二个阶段。</p>
<h4 id="reallocate"><a href="#reallocate" class="headerlink" title="reallocate"></a>reallocate</h4><p>如果是第一次使用缓存，一定会进入<code>reallocate</code>流程，进行初始化，开辟容量为<code>4</code>的<code>buckets</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity)</span><br><span class="line">&#123;</span><br><span class="line">    bool freeOld = canBeFreed();</span><br><span class="line">    <span class="comment">//获取旧的buckets</span></span><br><span class="line">    bucket_t *oldBuckets = buckets();</span><br><span class="line">    <span class="comment">//开辟新的buckets</span></span><br><span class="line">    bucket_t *newBuckets = allocateBuckets(newCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache's old contents are not propagated. </span></span><br><span class="line">    <span class="comment">// This is thought to save cache memory at the cost of extra cache fills.</span></span><br><span class="line">    <span class="comment">// fixme re-measure this</span></span><br><span class="line"></span><br><span class="line">    assert(newCapacity &gt; <span class="number">0</span>);</span><br><span class="line">    assert((uintptr_t)(mask_t)(newCapacity<span class="number">-1</span>) == newCapacity<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据新的buckets，更新buckets和mask </span></span><br><span class="line">    setBucketsAndMask(newBuckets, newCapacity - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (freeOld) &#123;</span><br><span class="line">        <span class="comment">//释放就的buckets</span></span><br><span class="line">        cache_collect_free(oldBuckets, oldCapacity);</span><br><span class="line">        cache_collect(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法也比较简单。我们需要关注四点。</p>
<ol>
<li><code>mask</code>被设置的值为开辟空间的<code>newCapacity-1</code></li>
<li>在开辟新的数组时，会释放旧<code>buckets</code> （加入回收数组）   </li>
<li>旧的缓存不会被计入新的数组中。保持局部性原理为最佳</li>
<li><p>选择在<code>3/4</code>的时间扩容，是为了保持hash 的高效查找，因为<code>hash table</code>的剩余容量越小，意味着冲突也越多。  </p>
<p>回到<code>cache_fill_nolock</code>的第二阶段，上面分析了第一个<code>if</code>即<code>reallocate</code>，在下面的<code>else if</code>中，也就是如果当前设置后的缓存数仍然小于总量的<code>3/4</code>，则继续使用当前<code>buckets</code>，否则<code>else</code>进行扩容<code>expend</code></p>
<h4 id="expend"><a href="#expend" class="headerlink" title="expend"></a>expend</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cache_t::expand()</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line">    <span class="comment">//获取旧的容量</span></span><br><span class="line">    uint32_t oldCapacity = capacity();</span><br><span class="line">    <span class="comment">//计算需要开辟新空间的大小 = 旧的大小 * 2</span></span><br><span class="line">    uint32_t newCapacity = oldCapacity ? oldCapacity*<span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((uint32_t)(mask_t)newCapacity != newCapacity) &#123;</span><br><span class="line">        <span class="comment">// 溢出不进行容量加大，但是仍会从新申请。</span></span><br><span class="line">        <span class="comment">// mask overflow - can't grow further</span></span><br><span class="line">        <span class="comment">// fixme this wastes one bit of mask</span></span><br><span class="line">        newCapacity = oldCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reallocate(oldCapacity, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个方法比较简单。我们需要关注两点。</p>
<ol>
<li>在不超过<code>uint32_t</code>的情况下，每次扩容为原来大小的<code>2</code>倍</li>
<li>如果超过了<code>uint32_t</code>，则重新申请跟原来一样大小的<code>buckets</code>。   </li>
</ol>
<p>接下来就是做后一个阶段了，查找缓存。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bucket_t * cache_t::find(cache_key_t k, id receiver)</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//参数k, SEL强转为 uintptr_t 类型的 无符号整形数字。</span></span><br><span class="line">    assert(k != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//拿到buckets数组</span></span><br><span class="line">    bucket_t *b = buckets();</span><br><span class="line">    <span class="comment">//获取mask = 总容量 - 1。 </span></span><br><span class="line">    mask_t m = mask();</span><br><span class="line">    <span class="comment">//k &amp; mask，哈希算法</span></span><br><span class="line">    mask_t begin = cache_hash(k, m);</span><br><span class="line">    mask_t i = begin;</span><br><span class="line">    <span class="keyword">do</span> &#123;<span class="comment">//找到的key是空的bucket，或者找到了目标k(SEL)</span></span><br><span class="line">        <span class="keyword">if</span> (b[i].key() == <span class="number">0</span>  ||  b[i].key() == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环条件为 最后尝试的位置 = 开始位置。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ((i = cache_next(i, m)) != begin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hack</span></span><br><span class="line">    <span class="comment">// 按照正常的查找逻辑，不会走到这里，因为buckets的可使用容量为总容量的3/4，那么上面的while一定会命中一个空的桶，然后返回。</span></span><br><span class="line">    <span class="comment">// 所以到这里一定是缓存出现了一些问题，具体的问题会在bad_cache中 log 出来</span></span><br><span class="line">    Class cls = (Class)((uintptr_t)<span class="keyword">this</span> - offsetof(objc_class, cache));</span><br><span class="line">    cache_t::bad_cache(receiver, (SEL)k, cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这里我们可以发现，<code>cache_t</code>采用哈希表的方式来查找对应的<code>bucket</code>，哈希函数为<code>cache_hash</code>，目标数组为<code>buckets</code>。步骤如下：</p>
<ol>
<li>准备哈希查找的<code>k</code>和目标数组<code>buckets</code>。</li>
<li>线性探测的方式查找目标<code>k</code>，直到找到<code>k</code>或者空的<code>bucket</code>。</li>
<li>异常处理。  </li>
</ol>
<p>到这里大体的流程已经梳理清晰，但还有一个比较重要的问题。我们知道<code>msgSend</code>是可多线程并发执行的，那么<code>cache_t</code>在更新缓存时，如何处理线程安全的问题呢。</p>
<ol>
<li>在每次执行缓存填充，和扩充都会添加对应的互斥锁。</li>
<li>在更新<code>buckets</code>和<code>mask</code>时，会使用<code>mega_barrier</code> 来保证<code>buckets</code>的更新一定早于<code>mask</code>。（如果不保证会有数组越界的问题）</li>
<li>在回收旧的<code>buckets</code>时，会把需要释放的<code>buckets</code>加入一个全局的数组<code>garbage_refs</code>中。等待真正没有其他线程使用数组中的元素时，在进行释放。  </li>
</ol>
<p>代码验证<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/2F9B5925-AEFC-4C0D-BAE0-13A1ED7B0EA5.png" alt="img"><br>step over<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/F7D3F61B-539B-423A-A3B4-0AE95CAE0D45.png" alt="img"><br>继续 step over<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/F7D3F61B-539B-423A-A3B4-0AE95CAE0D45.png" alt="img"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/cache_t.png" alt="img"></p>
<h3 id="class-data-bits-t"><a href="#class-data-bits-t" class="headerlink" title="class_data_bits_t"></a>class_data_bits_t</h3><p><code>class_data_bits_t</code>是一个<code>uintptr_t</code> 类型的指针，在编译阶段会指向<code>class_ro_t</code>,在运行时会封装成<code>class_rw_t</code></p>
<h4 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h4><p><code>class_ro_t</code>的结构如下<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/9417849E-AED4-419F-A4E9-B9C105BEC2BA.png" alt="img"><br><code>class_ro_t</code>存储了很多在编译时期就确定的类的信息。其内部包含了类名、ivar、方法、属性等。是只读类型的结构。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;               <span class="comment">//配合mask 可以用来判断，元类，根类等          </span></span><br><span class="line">    uint32_t instanceStart;       <span class="comment">//non-fragile判断依据</span></span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> char * name;           </span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *baseMethods() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>instanceStart</code>和<code>instanceSize</code>是为了实现<code>Non Fragile<code>特性。</code></code></p>
<blockquote>
<p>In the legacy runtime, if you change the layout of instance variables in a class, you must recompile classes that inherit from it.<br>In the modern runtime, if you change the layout of instance variables in a class, you do not have to recompile classes that inherit from it.  </p>
</blockquote>
<p>下面我们来读取下<code>class_ro_t</code>的信息，为了证明<code>class_ro_t</code>是在编译期期确定，我们要在<code>runtime</code>的入口下个符号断点<code>objc_init</code>(这也可以先运行一次，先得到类对象的地址，第二次符号断点直接使用)。由于<code>objc_init</code>是<code>runtime</code>入口(runtime还没有处理类的元数据)。<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/5C93DDAA-4939-4694-B13C-2A763B913192.png" alt="img"></p>
<h4 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h4><p>从上面的章节看出<code>class_ro_t</code>存储的大多是类在编译时就已经确定的信息，但是<code>Objective-C</code>又是一门动态语言，因此需要另一个可以运行时<code>读写</code>数据，也就是<code>class_rw_t</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    uint32_t flags;           <span class="comment">//同样结合mask 使用</span></span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro;     <span class="comment">//ro的指针</span></span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    char *demangledName;      <span class="comment">//是计算机语言用于解决实体名称唯一性的一种方法，做法是向名称中添加一些类型信息，用于从编译器中向链接器传递更多语义信息</span></span><br><span class="line"></span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">    uint32_t index;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>值得注意的是<code>method_array_t</code>的结构会有三种变化。</p>
<ul>
<li>空。</li>
<li>一个一维数组的指针。(默认为一维数组，就算一个类有category，如果没有实现+load，就也是一维数组，没有实现+load，就意味这个类可以懒加载)</li>
<li>指向列表的指针数组。(当一个类存在category且这个类无法懒加载，或者动态修改方法列表如addMethod。就会生成二维列表，)  </li>
</ul>
<p>如果从二进制的角度讲，只要这个类存在于<code><strong>objc_catlist</strong></code>或者<code>objc_nlcatlist</code>，那么他的<code>method_array_t</code>就为二维数组。<br>那么<code>class_rw_t</code>是什么时候被赋值的呢。</p>
<h5 id="realizeClass"><a href="#realizeClass" class="headerlink" title="realizeClass"></a>realizeClass</h5><p>首先简单看一个runtime初始化的流程。  </p>
<ol>
<li>objc_init</li>
<li>read_images。  <ol>
<li>初始化全局class map，读取macho的 <strong>objc_classlist 初始化全局class map， </strong>objc_classrefs。</li>
<li>读取 __objc_selrefs等段读取相关。进行 sel fix up</li>
<li>读取 protocol</li>
<li>读取所有 非懒加载 类，并调用 realizeClass进行初始化，进一步调用 methodizeClass(Attach categories)</li>
<li>读取categories，把读取出来的categories放到全局的map 里，如果cat 关联的cls已经被realize则进行remethodizeClass</li>
</ol>
</li>
<li>对所有非懒加载的类 和 category 执行 +load。  </li>
</ol>
<p>类的可读写元数据的初始话主要发生在 <code>realizeClass</code>和<code>methodizeClass</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class realizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    ... </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme verify class is not in an un-dlopened part of the shared cache?</span></span><br><span class="line">    <span class="comment">//RO_FUTURE 标志位来记录是否可以直接强转。</span></span><br><span class="line">    ro = (<span class="keyword">const</span> class_ro_t *)cls-&gt;data();</span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        <span class="comment">// This was a future class. rw data is already allocated.</span></span><br><span class="line">        rw = cls-&gt;data();</span><br><span class="line">        ro = cls-&gt;data()-&gt;ro;</span><br><span class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不能转换，则开辟空间。</span></span><br><span class="line">        <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">        rw = (class_rw_t *)calloc(sizeof(class_rw_t), <span class="number">1</span>);</span><br><span class="line">        rw-&gt;ro = ro;</span><br><span class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING;</span><br><span class="line">        cls-&gt;setData(rw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line"></span><br><span class="line">    rw-&gt;version = isMeta ? <span class="number">7</span> : <span class="number">0</span>;  <span class="comment">// old runtime went up to 6</span></span><br><span class="line">    ...</span><br><span class="line">    优先执行supercls 和metacls 的realize</span><br><span class="line">    检测isa 优化</span><br><span class="line">    更新实例大小，关联子类父类，元类根类。</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Attach categories</span></span><br><span class="line">    methodizeClass(cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>realizeClass</code>方法中会根据<code>ro</code>中的<code>flags</code>和<code>RO_FUTURE</code>来判断是否可以直接进行类型转换，如不可以则需要另外给<code>rw</code>申请内存。同时也注意到，在生成<code>rw</code>后，并没有进行方法属性等列表的赋值，而方法等列表的拼接是在<code>methodizeClass</code>中<br>下面我们来尽代码验证。<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/F82FD932-55BD-4192-9696-EA867FF8071A.png" alt="img"><br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/BC67DB9F-2DA5-46E4-AB43-873589F409F8.png" alt="img"></p>
<h5 id="methodizeClass"><a href="#methodizeClass" class="headerlink" title="methodizeClass"></a>methodizeClass</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> methodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    <span class="comment">//获取realizeClass 中设置好的rw</span></span><br><span class="line">    bool isMeta = cls-&gt;isMetaClass();</span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line">    auto ro = rw-&gt;ro;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Install methods and properties that the class implements itself.</span></span><br><span class="line">    <span class="comment">//开始拼接method,注意经过拼接之后仍然是1维数组。</span></span><br><span class="line">    method_list_t *list = ro-&gt;baseMethods();</span><br><span class="line">    <span class="keyword">if</span> (list) &#123;</span><br><span class="line">        prepareMethodLists(cls, &amp;list, <span class="number">1</span>, YES, isBundleClass(cls));</span><br><span class="line">        rw-&gt;methods.attachLists(&amp;list, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Attach categories.</span></span><br><span class="line">    category_list *cats = unattachedCategoriesForClass(cls, <span class="literal">true</span> <span class="comment">/*realizing*/</span>);</span><br><span class="line">    attachCategories(cls, cats, <span class="literal">false</span> <span class="comment">/*don't flush caches*/</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于此时执行到<code>methodizeClass</code>时，<code>rw</code>中的methods 还为初始化，所以，在加下来的<code>attachLists</code>过程中一定产生的是一维数组(因为使用 ro-&gt;baseMethods中的方法列表拼接，但是 ro-&gt;baseMethods 一定是一维数组。)<br>同时我们截取一段<code>rw</code>中<code>methods</code>也就是code&gt;list_array_tt的<code>attachLists</code>实现。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attachLists(List* <span class="keyword">const</span> * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//二维数组已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        uint32_t oldCount = array()-&gt;count;</span><br><span class="line">        uint32_t newCount = oldCount + addedCount;</span><br><span class="line">        setArray((array_t *)realloc(array(), <span class="attr">array_t</span>::byteSize(newCount)));</span><br><span class="line">        array()-&gt;count = newCount;</span><br><span class="line">        memmove(array()-&gt;lists + addedCount, array()-&gt;lists, </span><br><span class="line">                oldCount * sizeof(array()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * sizeof(array()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!list  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//当前list 还未初始化，需要添加的数组（二维）的元素=1，此时直接使用这个addedLists[0]</span></span><br><span class="line">        <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">        list = addedLists[<span class="number">0</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果list已经存在，且二维数组不存在，那么构建二维数组结构。</span></span><br><span class="line">        <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">        List* oldList = list;</span><br><span class="line">        uint32_t oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        uint32_t newCount = oldCount + addedCount;</span><br><span class="line">        setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">        array()-&gt;count = newCount;</span><br><span class="line">        <span class="keyword">if</span> (oldList) array()-&gt;lists[addedCount] = oldList;</span><br><span class="line">        memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * sizeof(array()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续验证。<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/E444A701-A9A9-4A92-A0A4-B91127730270.png" alt="img"><br>下面我们来查看methods里面的内容。<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/437FAD4A-1FEA-4CDA-AC3E-A258E1EE64C8.png" alt="img"><br>那么什么时候才会变成二维数组呢，答案是 <code>attachCategories</code>之后，注意存在category不一定就会调用<code>attachCategories</code>的呦，有兴趣的可以看下源码。下面我们直接看<code>lldb</code><br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/F201FDF1-7660-4E55-9DC5-E4B3BE6AC421.png" alt="img"><br>接下来 step over<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/AEE7605B-A5FF-4214-AE73-27FC3B720155.png" alt="img"><br>注意如果你的category直接是基于<code>NSObject</code>那么调试结果会有不一样，因为<code>NSObject</code>为<code>非懒加载</code>的类，如果是<code>NSObject</code>的子类(Person)的category又没有实现<code>+load</code>那么一样不会执行<code>attachCategories</code>，因为<code>Person</code>的category此时不会被编译到<code><strong>objc_catlist</strong></code>或者<code>objc_nlcatlist</code>段，runtime也就获取不到对应的Categories，如果<code>Person</code>实现了<code>+load</code>，那么代表此category为非懒加载，需要生成对应的data 段，之后就可以被<code>attachCategories</code>了</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>至此我们对于开篇提出的第一个问题</p>
<blockquote>
<p><code>Objective-C</code>是如何基于C语言来设计对象模型。  </p>
</blockquote>
<p>通过上面的梳理，我们可以认为，<code>Objective-C</code>为了使<code>C</code>具有面向对象以及动态性的能力，会通过如下手段来实现：</p>
<ol>
<li>使用<code>struct</code>来构建对象模型。</li>
<li>在<code>struct</code>中通过定义<code>isa</code>来区分对象的“类型”，从而实现内省等特性。</li>
<li>在<code>struct</code>中通过定义<code>supercls</code>来实现继承的能力。</li>
<li>在<code>struct</code>中定义<code>ro</code>来存储对象的属性，方法。</li>
<li>在<code>struct</code>中定义<code>rw</code>来实现动态性。使得开发者有运行时修改的能力。  </li>
</ol>
<p>下面我们来看看“消息”。</p>
<h2 id="消息查找"><a href="#消息查找" class="headerlink" title="消息查找"></a>消息查找</h2><p>介绍完<code>Objective-C</code>的基础数据结构，接下来就是方法的调用了。在讨论“消息”之前。我们先来思考一下，我们总是在说在<code>objc</code>中，调用方法实际上是<code>发送消息</code>，那么这个消息的机制是什么？  函数调用的本质应该是什么？我们可以通过一段C的代码来看下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> func()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面通过<code>clang</code>和<code>objdump</code>命令来生成可执行文件并查看汇编实现<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/75BB4990-0654-4F77-867B-EEFD1F725D50.png" alt="img"><br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/06D2A0A7-AC2A-4006-8E57-2C2FEAC61816.png" alt="img"><br>我们可以看到，函数的调用，实际上就是“地址”的跳转。而函数的地址是在编译期就能确定的(除一些动态库函数外)，关于如何在编译期确定地址可以查看之前的<a href="https://devyang.space/2019/12/03/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/#more" target="_blank" rel="noopener">静态链接文章</a>。  </p>
<p>但是<code>Objective-C</code>是一门动态性语言，如果直接使用编译得到的地址，就不存在动态性，那么<code>Objective-C</code>是如何解决这个问题的呢</p>
<h3 id="msgSend"><a href="#msgSend" class="headerlink" title="msgSend"></a>msgSend</h3><p>此汇编结果为<code>iOS13.2.3</code>真机版本的runtime。可参考<a href="https://modexp.wordpress.com/2018/10/30/arm64-assembly/#bitmanip" target="_blank" rel="noopener">arm64汇编文档</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">libobjc.A.dylib<span class="string">`objc_msgSend:</span></span><br><span class="line"><span class="string">    //判断self 是否 = nil</span></span><br><span class="line"><span class="string">-&gt;  0x1810aa080 &lt;+0&gt;:   cmp    x0, #0x0                  ; =0x0</span></span><br><span class="line"><span class="string">    //如果是0或者小0，则跳转至 0x1810aa0f8 处</span></span><br><span class="line"><span class="string">    0x1810aa084 &lt;+4&gt;:   b.le   0x1810aa0f8               ; &lt;+120&gt;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //读取x0的“值”存入x13中。x13=isa    </span></span><br><span class="line"><span class="string">    0x1810aa088 &lt;+8&gt;:   ldr    x13, [x0]</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //x16 = x13 &amp; isamask  </span></span><br><span class="line"><span class="string">    //xl6 = cls     </span></span><br><span class="line"><span class="string">    0x1810aa08c &lt;+12&gt;:  and    x16, x13, #0xffffffff8</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //读取x16偏移16字节的值，存入 x11</span></span><br><span class="line"><span class="string">    //x11 = cache_t和mask_t共同组成,前48位为cache_t</span></span><br><span class="line"><span class="string">    0x1810aa090 &lt;+16&gt;:  ldr    x11, [x16, #0x10]</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    /*  CacheLookup */</span></span><br><span class="line"><span class="string">    //苹果开源的runtime(mac10.14)中，cache存储在cls偏移16字节处    </span></span><br><span class="line"><span class="string">    //但在目前的版本中(10.15)，cache_t会和mask_t公用这8个字节。使用0xffffffffffff获取cache_t。</span></span><br><span class="line"><span class="string">    //x10 = bucket_t = (x11 &amp; 0xffffffffffff)</span></span><br><span class="line"><span class="string">    0x1810aa094 &lt;+20&gt;:  and    x10, x11, #0xffffffffffff</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //x11 &gt;&gt; 48获取mask_t,  </span></span><br><span class="line"><span class="string">    //x12 = mask_t &amp; SEL = cache_hash(buckets的索引)</span></span><br><span class="line"><span class="string">    0x1810aa098 &lt;+24&gt;:  and    x12, x1, x11, lsr #48</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //获取索引值相对buckets首地址的偏移量，cache_hash &lt;&lt; 4,因为每个bucket占16字节，所以把索引 * 16；</span></span><br><span class="line"><span class="string">    //x12:取索引对应的bucket = buckets首地址+索引偏移量</span></span><br><span class="line"><span class="string">    0x1810aa09c &lt;+28&gt;:  add    x12, x10, x12, lsl #4</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //读取bucket的内容，分别存入 x17，x9</span></span><br><span class="line"><span class="string">    //x17 = imp,  x9 = cache_key(SEL)</span></span><br><span class="line"><span class="string">    0x1810aa0a0 &lt;+32&gt;:  ldp    x17, x9, [x12]</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //cachekey == SEL</span></span><br><span class="line"><span class="string">    0x1810aa0a4 &lt;+36&gt;:  cmp    x9, x1</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //cachekey != SEL，跳转到 0x1810aa0b4</span></span><br><span class="line"><span class="string">    0x1810aa0a8 &lt;+40&gt;:  b.ne   0x1810aa0b4               ; &lt;+52&gt;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    /*  CacheHit */</span></span><br><span class="line"><span class="string">    0x1810aa0ac &lt;+44&gt;:  eor    x17, x17, x16    </span></span><br><span class="line"><span class="string">    //直接执行cache中的IMP</span></span><br><span class="line"><span class="string">    0x1810aa0b0 &lt;+48&gt;:  br     x17</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    /*  CheckMiss */    </span></span><br><span class="line"><span class="string">    //调用x9 是否为0 。如果为0 ，这说明这个bucket是空桶，就跳转 _objc_msgSend_uncached-&gt;lookupIMPOrForward</span></span><br><span class="line"><span class="string">    0x1810aa0b4 &lt;+52&gt;:  cbz    x9, 0x1810aa3c0           ; _objc_msgSend_uncached</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //对比对应出的bucket_t 是否等于 buckets首地址</span></span><br><span class="line"><span class="string">    0x1810aa0b8 &lt;+56&gt;:  cmp    x12, x10</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //如果相等，说明找了一圈，仍没有找到，则跳转至 0x1810aa0c8。</span></span><br><span class="line"><span class="string">    0x1810aa0bc &lt;+60&gt;:  b.eq   0x1810aa0c8               ; &lt;+72&gt;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //bucket_t的地址详情偏移16，相当于 取当前bucket_t的前一个元素。</span></span><br><span class="line"><span class="string">    //把imp和key分别赋值给 x17 x9</span></span><br><span class="line"><span class="string">    0x1810aa0c0 &lt;+64&gt;:  ldp    x17, x9, [x12, #-0x10]!</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //跳转回0x1810aa0a4，相当于 向前循环遍历查找buckets</span></span><br><span class="line"><span class="string">    0x1810aa0c4 &lt;+68&gt;:  b      0x1810aa0a4               ; &lt;+36&gt;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //到这里说明 x12 是buckets中的第一个bucket。</span></span><br><span class="line"><span class="string">    //x11 为mask和buckets，这里右移 44位，说明了buckets实际只是用了 44bit而不是48</span></span><br><span class="line"><span class="string">    //这里相当于把x12重新指向buckets的最后一个bucekt。</span></span><br><span class="line"><span class="string">    //x12 = buckets-&gt;last</span></span><br><span class="line"><span class="string">    0x1810aa0c8 &lt;+72&gt;:  add    x12, x12, x11, lsr #44</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //将bucket的imp和key 写入 x17 和 x9</span></span><br><span class="line"><span class="string">    0x1810aa0cc &lt;+76&gt;:  ldp    x17, x9, [x12]</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //对比 SEL == key</span></span><br><span class="line"><span class="string">    0x1810aa0d0 &lt;+80&gt;:  cmp    x9, x1</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //不相等 跳转到 0x1810aa0e0，判断cache_key 是否为空</span></span><br><span class="line"><span class="string">    0x1810aa0d4 &lt;+84&gt;:  b.ne   0x1810aa0e0               ; &lt;+96&gt;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    /*  CacheHit */</span></span><br><span class="line"><span class="string">    //如果相等则</span></span><br><span class="line"><span class="string">    0x1810aa0d8 &lt;+88&gt;:  eor    x17, x17, x16</span></span><br><span class="line"><span class="string">    //执行x17:IMP</span></span><br><span class="line"><span class="string">    0x1810aa0dc &lt;+92&gt;:  br     x17</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    /*  CheckMiss */    </span></span><br><span class="line"><span class="string">    //如果此时 x9 == 0 则执行_objc_msgSend_uncached</span></span><br><span class="line"><span class="string">    0x1810aa0e0 &lt;+96&gt;:  cbz    x9, 0x1810aa3c0           ; _objc_msgSend_uncached</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //对比对应出的bucket_t 是否等于 buckets首地址</span></span><br><span class="line"><span class="string">    0x1810aa0e4 &lt;+100&gt;: cmp    x12, x10</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //如果等于则跳转0x1810aa0f4 -&gt; _objc_msgSend_uncached</span></span><br><span class="line"><span class="string">    0x1810aa0e8 &lt;+104&gt;: b.eq   0x1810aa0f4               ; &lt;+116&gt;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //不相等则 向前查找</span></span><br><span class="line"><span class="string">    0x1810aa0ec &lt;+108&gt;: ldp    x17, x9, [x12, #-0x10]!</span></span><br><span class="line"><span class="string">    //跳转0x1810aa0d0</span></span><br><span class="line"><span class="string">    0x1810aa0f0 &lt;+112&gt;: b      0x1810aa0d0               ; &lt;+80&gt;</span></span><br><span class="line"><span class="string">    //跳转_objc_msgSend_uncached</span></span><br><span class="line"><span class="string">    0x1810aa0f4 &lt;+116&gt;: b      0x1810aa3c0               ; _objc_msgSend_uncached</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //msgSeng刚开始的第二行判断，这里是nil或者tagged</span></span><br><span class="line"><span class="string">    0x1810aa0f8 &lt;+120&gt;: b.eq   0x1810aa130               ; &lt;+176&gt;</span></span><br><span class="line"><span class="string">    0x1810aa0fc &lt;+124&gt;: adrp   x10, 294986</span></span><br><span class="line"><span class="string">    0x1810aa100 &lt;+128&gt;: add    x10, x10, #0x340          ; =0x340 </span></span><br><span class="line"><span class="string">    0x1810aa104 &lt;+132&gt;: lsr    x11, x0, #60</span></span><br><span class="line"><span class="string">    0x1810aa108 &lt;+136&gt;: ldr    x16, [x10, x11, lsl #3]</span></span><br><span class="line"><span class="string">    0x1810aa10c &lt;+140&gt;: adrp   x10, 294986</span></span><br><span class="line"><span class="string">    0x1810aa110 &lt;+144&gt;: add    x10, x10, #0x2a8          ; =0x2a8 </span></span><br><span class="line"><span class="string">    0x1810aa114 &lt;+148&gt;: cmp    x10, x16</span></span><br><span class="line"><span class="string">    0x1810aa118 &lt;+152&gt;: b.ne   0x1810aa090               ; &lt;+16&gt;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // ext tagged</span></span><br><span class="line"><span class="string">    0x1810aa11c &lt;+156&gt;: adrp   x10, 294986</span></span><br><span class="line"><span class="string">    0x1810aa120 &lt;+160&gt;: add    x10, x10, #0x3c0          ; =0x3c0 </span></span><br><span class="line"><span class="string">    0x1810aa124 &lt;+164&gt;: ubfx   x11, x0, #52, #8</span></span><br><span class="line"><span class="string">    0x1810aa128 &lt;+168&gt;: ldr    x16, [x10, x11, lsl #3]</span></span><br><span class="line"><span class="string">    0x1810aa12c &lt;+172&gt;: b      0x1810aa090               ; &lt;+16&gt;</span></span><br><span class="line"><span class="string">    0x1810aa130 &lt;+176&gt;: mov    x1, #0x0</span></span><br><span class="line"><span class="string">    0x1810aa134 &lt;+180&gt;: movi   d0, #0000000000000000</span></span><br><span class="line"><span class="string">    0x1810aa138 &lt;+184&gt;: movi   d1, #0000000000000000</span></span><br><span class="line"><span class="string">    0x1810aa13c &lt;+188&gt;: movi   d2, #0000000000000000</span></span><br><span class="line"><span class="string">    0x1810aa140 &lt;+192&gt;: movi   d3, #0000000000000000</span></span><br><span class="line"><span class="string">    0x1810aa144 &lt;+196&gt;: ret    </span></span><br><span class="line"><span class="string">    0x1810aa148 &lt;+200&gt;: nop    </span></span><br><span class="line"><span class="string">    0x1810aa14c &lt;+204&gt;: nop    </span></span><br><span class="line"><span class="string">    0x1810aa150 &lt;+208&gt;: nop    </span></span><br><span class="line"><span class="string">    0x1810aa154 &lt;+212&gt;: nop    </span></span><br><span class="line"><span class="string">    0x1810aa158 &lt;+216&gt;: nop    </span></span><br><span class="line"><span class="string">    0x1810aa15c &lt;+220&gt;: nop</span></span><br></pre></td></tr></table></figure></p>
<p>整个<code>objc_msgsend</code>可分为四个阶段：</p>
<ol>
<li>准备工作，包括获取<code>类对象</code>，<code>mask_t</code>，<code>cash_hash(查找索引)</code>，<code>buckets</code>等</li>
<li>获取<code>cash_hash</code>所在<code>buckets</code>的<code>bucket</code>，并向前遍历查找，这里有3中情况：<ol>
<li>如果找到则调用<code>IMP</code>。</li>
<li>如果找到的<code>bucket.key == 0</code>，即<code>bucket</code>为空桶，则调用 <code>objc_msgSend_uncached</code></li>
<li>如果找到第一个<code>bucket</code>，则跳转到3。  </li>
</ol>
</li>
<li>从<code>buckets</code>的最后一个向前查找：<ol>
<li>如果找到则调用<code>IMP</code>。</li>
<li>如果找到的<code>bucket.key == 0</code>，即<code>bucket</code>为空桶，则调用 <code>objc_msgSend_uncached</code>。  </li>
</ol>
</li>
<li>调用<code>objc_msgSend_uncached</code>。    </li>
</ol>
<h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><p>由于汇编看起来不是很直观，可直接参考下面的伪代码，同时这部分伪代码没有处理关于参数和返回值的逻辑。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> discover_msgSend(id self,SEL sel1)&#123;</span><br><span class="line">    <span class="keyword">if</span> (self == nil) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SEL sel = sel1;</span><br><span class="line">    Class clsHasMask = *(Class *)self;</span><br><span class="line">    Class cls = (Class)((uintptr_t)clsHasMask &amp; <span class="number">0xffffffff8</span>);</span><br><span class="line">    struct cache_t * cache = (struct cache_t *)((__bridge <span class="keyword">void</span> *)cls + <span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    struct bucket_t *_buckets = (struct bucket_t *)((uintptr_t)cache-&gt;_buckets &amp; <span class="number">0xffffffffffff</span>);</span><br><span class="line">    uintptr_t mask = (uintptr_t)cache-&gt;_buckets &gt;&gt; <span class="number">48</span>;</span><br><span class="line">    uintptr_t cache_hash = (uintptr_t)sel &amp; mask;</span><br><span class="line">    struct bucket_t* bucket = (_buckets + cache_hash*<span class="number">1</span>);<span class="comment">//cache_hash*16</span></span><br><span class="line">    <span class="comment">/*  CacheLookup */</span></span><br><span class="line">    <span class="keyword">while</span> ((*bucket)._key != (uintptr_t)sel) &#123;</span><br><span class="line">        <span class="comment">/*  CheckMiss */</span></span><br><span class="line">        <span class="keyword">if</span> ((*bucket)._key == <span class="number">0</span>) &#123;</span><br><span class="line">            goto _objc_msgSend_uncached;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*  查找到第一个元素了 */</span></span><br><span class="line">        <span class="keyword">if</span> (bucket == _buckets) &#123;</span><br><span class="line">            goto second_loop;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket = (bucket<span class="number">-1</span>);<span class="comment">//[x12, #-0x10]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(((*bucket)._key) == (uintptr_t)sel)&#123;</span><br><span class="line">        IMP x16 = ((uintptr_t)(*bucket)._imp) ^ (uintptr_t)cls;</span><br><span class="line">        x16();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        goto _objc_msgSend_uncached;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">second_loop:</span><br><span class="line">    &#123;</span><br><span class="line">        int64_t offset = ((uintptr_t)cache-&gt;_buckets &gt;&gt; <span class="number">44</span>);</span><br><span class="line">        struct bucket_t* lastBucket = (_buckets + offset/<span class="number">16</span>);</span><br><span class="line">        <span class="comment">/*  CacheLookup */</span></span><br><span class="line">        <span class="keyword">while</span> ((*lastBucket)._key != (uintptr_t)sel) &#123;</span><br><span class="line">            <span class="comment">/*  CheckMiss */</span></span><br><span class="line">            <span class="keyword">if</span> ((*lastBucket)._key == <span class="number">0</span>) &#123;</span><br><span class="line">                goto _objc_msgSend_uncached;</span><br><span class="line">            &#125;</span><br><span class="line">            lastBucket = (lastBucket<span class="number">-1</span>);<span class="comment">//[x12, #-0x10]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(((*lastBucket)._key) == (uintptr_t)sel)&#123;</span><br><span class="line">            IMP x16 = ((uintptr_t)(*lastBucket)._imp) ^ (uintptr_t)cls;</span><br><span class="line">            x16();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">/*  JumpMiss */</span></span><br><span class="line">            goto _objc_msgSend_uncached;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">_objc_msgSend_uncached:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"\n _objc_msgSend_uncached -&gt; lookUpImpOrForward"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的流程我们发现，<code>objc_msgSend</code>会有两次的查找行为，这又是为什么呢？我们可以通过<code>runtime</code>的源码中找到答案。</p>
<blockquote>
<p>Clone scanning loop to miss instead of hang when cache is corrupt.<br>The slow path may detect any corruption and halt later.  </p>
</blockquote>
<p>我们将第一个循环称为：原始循环，第二个称为：检查循环。<br>首先假设出现了缓存系统出现了异常，则此时有两种情况：</p>
<ul>
<li>仍然有一部分缓存是可用的，那么此检查的存在是不会影响该可用缓存部分的，因为arm64下缓存本来就是在buckets中向前进行写入的。所以当遍历到buckets的第一个bucket时的正常逻辑就是跳转到最后一项继续查找</li>
<li>有一部分不可用的缓存，为了避免在原始循环中再次被重新使用，可以使用该检查循环跳出查找过程。  </li>
</ul>
<h4 id="objc-msgSend-uncached"><a href="#objc-msgSend-uncached" class="headerlink" title="objc_msgSend_uncached"></a>objc_msgSend_uncached</h4><p>在<code>objc_msgSend</code>的汇编查找过程中，我们发现如果在缓存中找不到IMP。则会调用<code>objc_msgSend_uncached</code>。最终会调用到<code>lookUpImpOrForward</code>。</p>
<h3 id="lookUpImpOrForward"><a href="#lookUpImpOrForward" class="headerlink" title="lookUpImpOrForward"></a>lookUpImpOrForward</h3><p><code>lookUpImpOrForward</code>实现了一套查找 IMP 的标准路径，也就是在消息转发（Forward）之前的逻辑。类似的方法还有<code>lookUpImpOrNil</code>，这两个API的区别在于<code>lookUpImpOrNil</code>不会返回含有forward类型的IMP，也就是说不会触发消息转发。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    bool triedResolver = NO;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimistic cache lookup</span></span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        <span class="comment">//cache_getImp 同样为汇编实现。</span></span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在方法搜索期间，将保持runtimeLock，以使方法查找+缓存填充相对于方法添加成为原子。</span></span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line">    <span class="comment">//如果类还没有realize，则先进行realize，一般懒加载的类会走此方法</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果类还没有初始化，则先进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">        <span class="comment">// If sel == initialize, _class_initialize will send +initialize and </span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">        <span class="comment">// from the messenger then it won't happen. 2778172</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"> retry:    </span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    <span class="comment">//获取当前类缓存</span></span><br><span class="line">    imp = cache_getImp(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (imp) goto done;</span><br><span class="line">    <span class="comment">//查找当前类的方法列表</span></span><br><span class="line">    &#123;</span><br><span class="line">        Method meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            <span class="comment">//如果找到则填充到缓存</span></span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找父类的缓存和方法列表</span></span><br><span class="line">    &#123;</span><br><span class="line">        unsigned attempts = unreasonableClassCount();</span><br><span class="line">        <span class="keyword">for</span> (Class curClass = cls-&gt;superclass;</span><br><span class="line">             curClass != nil;</span><br><span class="line">             curClass = curClass-&gt;superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Halt if there is a cycle in the superclass chain.</span></span><br><span class="line">            <span class="keyword">if</span> (--attempts == <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Memory corruption in class list."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Superclass cache.</span></span><br><span class="line">            imp = cache_getImp(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    <span class="comment">//如果找到且imp !=_objc_msgForward_impcache, 则填充到缓存到当前类的缓存中</span></span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                    goto done;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">                    <span class="comment">// Stop searching, but don't cache yet; call method </span></span><br><span class="line">                    <span class="comment">// resolver for this class first.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Superclass method list.</span></span><br><span class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">                <span class="comment">//如果找到则填充到缓存到当前类的缓存中</span></span><br><span class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">                imp = meth-&gt;imp;</span><br><span class="line">                goto done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No implementation found. Try method resolver once.</span></span><br><span class="line">    <span class="comment">//尝试动态方法解析</span></span><br><span class="line">    <span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">        <span class="comment">// Don't cache the result; we don't hold the lock so it may have </span></span><br><span class="line">        <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">        triedResolver = YES;</span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No implementation found, and method resolver didn't help. </span></span><br><span class="line">    <span class="comment">// Use forwarding.</span></span><br><span class="line">    <span class="comment">//没有执行动态方法解析，则获取存入一个forward 类型的 IMP。</span></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line">    <span class="comment">//返回IMP，可能是真正的实现，也可能是_objc_msgForward_impcache。</span></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法的流程如下：</p>
<ol>
<li>保证类已经经过<code>realize</code>和<code>initialize</code>，关于<code>realizeClass</code>已经在类的结构中介绍过了。</li>
<li>获取当前类的缓存或查找当前类的方法列表。如果找到则写入缓存。</li>
<li>查找父类的缓存或父类的方法列表，如果找到则写入缓存。</li>
<li>如果父类也没有，则进入动态方法解析阶段，并返回 2 重新尝试。</li>
<li>如果没有实现动态方法解析，则存入一个<code>forward</code>类型的<code>IMP</code></li>
<li>返回<code>IMP</code>，可能是真正的实现，也可能是<code>forward</code>。  </li>
</ol>
<p>接下里我们来详细分析 2 ~ 4的流程，而5，6将在消息转发章节分析。而流程  2 ~ 4 可以分为两个主要的函数，</p>
<ol>
<li>获取缓存 （当前类或父类）。</li>
<li>查找方法列表 （当前类或父类）。</li>
<li>缓存填充。  </li>
</ol>
<h4 id="cache-getImp"><a href="#cache-getImp" class="headerlink" title="cache_getImp"></a>cache_getImp</h4><p><code>cache_getImp</code>仍然使用汇编实现。其实现跟<code>objc_msgsend</code>中的<code>CacheLookup</code>阶段相似，区别是<code>objc_msgsend</code>中的<code>CacheLookup</code>在<code>CheckMiss</code>时会调用<code>objc_msgSend_uncached</code>，而<code>cache_getImp</code>则会在<code>CheckMiss</code>中返回 <code>0</code>。这里不在重复提供汇编代码，直接参考runtime源码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//定义汇编入口</span><br><span class="line">STATIC_ENTRY _cache_getImp</span><br><span class="line">    //同样先获取 cls,类对象</span><br><span class="line">    GetClassFromIsa_p16 p0</span><br><span class="line">    //进行缓存查找环节，在objc_msgsend中已经分析过了。这里参数传入 “GETIMP”</span><br><span class="line">    //如果CacheLookup查找失败则会返回LGetImpMiss。objc_msgsend是返回objc_msgSend_uncached</span><br><span class="line">    CacheLookup GETIMP</span><br><span class="line"></span><br><span class="line">LGetImpMiss:</span><br><span class="line">    //把返回值写入0并返回。</span><br><span class="line">    mov    p0, #0</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">    END_ENTRY _cache_getImp</span><br></pre></td></tr></table></figure></p>
<p>在<code>cache_getImp</code>调用过后，如果没有缓存，则会查找当前类的方法列表。</p>
<h4 id="getMethodNoSuper-nolock"><a href="#getMethodNoSuper-nolock" class="headerlink" title="getMethodNoSuper_nolock"></a>getMethodNoSuper_nolock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static method_t *</span><br><span class="line">getMethodNoSuper_nolock(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line">    // fixme nil cls? </span><br><span class="line">    // fixme nil sel?</span><br><span class="line"></span><br><span class="line">    for (auto mlists = cls-&gt;data()-&gt;methods.beginLists(), </span><br><span class="line">              end = cls-&gt;data()-&gt;methods.endLists(); </span><br><span class="line">         mlists != end;</span><br><span class="line">         ++mlists)</span><br><span class="line">    &#123;</span><br><span class="line">        method_t *m = search_method_list(*mlists, sel);</span><br><span class="line">        if (m) return m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过上一章节对class  结构的讲解，我们知道，<code>methods</code>的结构可能是二维数组也有可能是一维数组。这里通过对<code>methods</code>的<code>beginLists</code>和<code>endLists</code>进行迭代，使得迭代时总能得到一个装满<code>method</code>的数组，从而减少类型判断。<br>接下来我们来看<code>search_method_list</code></p>
<h5 id="search-method-list"><a href="#search-method-list" class="headerlink" title="search_method_list"></a>search_method_list</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> method_t *search_method_list(<span class="keyword">const</span> method_list_t *mlist, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    int methodListIsFixedUp = mlist-&gt;isFixedUp();</span><br><span class="line">    int methodListHasExpectedSize = mlist-&gt;entsize() == sizeof(method_t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMethodInSortedMethodList(sel, mlist);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Linear search of unsorted method list</span></span><br><span class="line">        <span class="keyword">for</span> (auto&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (meth.name == sel) <span class="keyword">return</span> &amp;meth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... debug</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__builtin_expect</code>表示对结果的一种期望：多数都是<code>ture</code>，也就是说，这里多数的时候都会继续调用<code>findMethodInSortedMethodList</code>，否则就会通过<code>线性遍历</code>来查找method。<br>需要注意的是，只有当<code>MethodList</code>已经是有序的时候，才能够进行有序的遍历方式，一下为对<code>MethodList</code>排序的时机：</p>
<ul>
<li>methodizeClass</li>
<li>attachCategories</li>
<li>addMethod</li>
<li>addMethods  </li>
</ul>
<p>其实也就是当方法列表的结构发生改变的时候，就会对该列表进行排序(注意是方法所在的列表进行排序，而不是rw里面的所有方法列表，如果是二维数组，只需重新排列当前方法所在的列表即可)，排序的规则为：按照 SEL 的地址升序排列。</p>
<h5 id="findMethodInSortedMethodList"><a href="#findMethodInSortedMethodList" class="headerlink" title="findMethodInSortedMethodList"></a>findMethodInSortedMethodList</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> method_t *findMethodInSortedMethodList(SEL key, <span class="keyword">const</span> method_list_t *list)</span><br><span class="line">&#123;</span><br><span class="line">    assert(list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> method_t * <span class="keyword">const</span> first = &amp;list-&gt;first;</span><br><span class="line">    <span class="keyword">const</span> method_t *base = first; <span class="comment">//base为二分查找的左起点</span></span><br><span class="line">    <span class="keyword">const</span> method_t *probe;</span><br><span class="line">    uintptr_t keyValue = (uintptr_t)key;</span><br><span class="line">    uint32_t count;</span><br><span class="line">    <span class="comment">//每次对 count/2。</span></span><br><span class="line">    <span class="keyword">for</span> (count = list-&gt;count; count != <span class="number">0</span>; count &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//左起点到count 的中间点。</span></span><br><span class="line">        probe = base + (count &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        uintptr_t probeValue = (uintptr_t)probe-&gt;name;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (keyValue == probeValue) &#123;</span><br><span class="line">            <span class="comment">// `probe` is a match.</span></span><br><span class="line">            <span class="comment">// Rewind looking for the *first* occurrence of this value.</span></span><br><span class="line">            <span class="comment">// This is required for correct category overrides.</span></span><br><span class="line">            <span class="keyword">while</span> (probe &gt; first &amp;&amp; keyValue == (uintptr_t)probe[<span class="number">-1</span>].name) &#123;</span><br><span class="line">                probe--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (method_t *)probe;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果目标sel &gt; 当前的probeValue，则需要向后查找。</span></span><br><span class="line">        <span class="keyword">if</span> (keyValue &gt; probeValue) &#123;</span><br><span class="line">            base = probe + <span class="number">1</span>;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数为一个二分查找的流程。有下面几个主要标记构成：</p>
<ul>
<li>二分查找的左右节点：base，count。</li>
<li>中间点：probe</li>
<li>对比查找标记，觉得向左还是向右：keyValue probeValue。  </li>
</ul>
<p>因此方法列表的查找流程可以总结为：</p>
<h4 id="log-and-fill-cache"><a href="#log-and-fill-cache" class="headerlink" title="log_and_fill_cache"></a>log_and_fill_cache</h4><p>在缓存查找和方法列表查找之后，就是进行缓存填充，这里如果在父类的方法列表找到了对应的<code>IMP</code>，则会把该<code>IMP</code>缓存在当前类中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">log_and_fill_cache(Class cls, IMP imp, SEL sel, id receiver, Class implementer)</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_MESSAGE_LOGGING</span><br><span class="line">    <span class="keyword">if</span> (objcMsgLogEnabled) &#123;</span><br><span class="line">        bool cacheIt = logMessageSend(implementer-&gt;isMetaClass(), </span><br><span class="line">                                      cls-&gt;nameForLogging(),</span><br><span class="line">                                      implementer-&gt;nameForLogging(), </span><br><span class="line">                                      sel);</span><br><span class="line">        <span class="keyword">if</span> (!cacheIt) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    cache_fill (cls, sel, imp, receiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>log_and_fill_cache</code>非常简单，命名也非常的清晰，分为log和填充缓存的步骤。而缓存填充最终会调用到<code>cache_fill_nolock</code>。<br><code>cache_fill_nolock</code>在上面的类结构中已经说明过了。</p>
<p>下面我们来总结一下消息查找的流程：<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/msgSend.png" alt="img"><br>接下来我们进入消息转发的流程处理。</p>
<h2 id="动态解析-amp-消息转发"><a href="#动态解析-amp-消息转发" class="headerlink" title="动态解析&amp;消息转发"></a>动态解析&amp;消息转发</h2><p>在上文的<code>objc_msgSend</code>中我们发现，如果无法找到<code>IMP</code>则会尝试进行到 <code>method resolver</code>流程。</p>
<h3 id="动态解析"><a href="#动态解析" class="headerlink" title="动态解析"></a>动态解析</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _class_resolveMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;   <span class="comment">//类对象或元类， 实例或类对象</span></span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现<code>_class_resolveMethod</code>的流程分为两步，按照是否为<code>元类</code>进行区分。首先我们来看非元类的情况</p>
<h4 id="实例方法的动态解析"><a href="#实例方法的动态解析" class="headerlink" title="实例方法的动态解析"></a>实例方法的动态解析</h4><p>如果<code>cls</code>不是元类，就用实例方法的动态解析。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> resolveInstanceMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, </span><br><span class="line">                         NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (<span class="keyword">typeof</span>(msg))objc_msgSend;</span><br><span class="line">    bool resolved = msg(cls, SEL_resolveInstanceMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn't fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveInstanceMethod adds to self a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: method %c[%s %s] "</span></span><br><span class="line">                         <span class="string">"dynamically resolved to %p"</span>, </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn't add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES"</span></span><br><span class="line">                         <span class="string">", but no new implementation of %c[%s %s] was found"</span>,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>首先确定现了Resolver 相关方法，如果没实现直接返回。</li>
<li>调用<code>resolveInstanceMethod</code>，获得返回值<code>resolved</code></li>
<li>重新进行<code>lookUpImpOrNil</code>并禁用<code>resolver</code>，目的是如果<code>resolveInstanceMethod</code>对该SEL进行实现，则把添加的IMP缓存起来。</li>
<li>根据<code>resolved</code>和<code>imp</code>,还有环境变量进行判断(假设开启了打印日志变量)：<ol>
<li>如果实现了<code>resolved</code>方法，并且也添加了对应的<code>imp</code>，则根据环境环境变量打印日志</li>
<li>否则，则说明<code>resolved</code>方法虽然返回了<code>ture</code>，<code>imp</code>却没有实现。  </li>
</ol>
</li>
</ol>
<p>上面的环境环境变量可以通过<code>OBJC_PRINT_RESOLVED_METHODS</code>来控制是否开启。</p>
<h4 id="类方法的动态解析"><a href="#类方法的动态解析" class="headerlink" title="类方法的动态解析"></a>类方法的动态解析</h4><p>我们注意到在<code>_class_resolveMethod</code>中的类方法流程中有一段注释：</p>
<blockquote>
<p>   try [nonMetaClass resolveClassMethod:sel]<br>and [cls resolveInstanceMethod:sel]。  </p>
</blockquote>
<p>这里的<code>nonMetaClass</code>指<code>_class_resolveMethod</code>参数中的<code>inst</code>(因为走得这里，cls一定是元类)。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> resolveClassMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line">    assert(cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, </span><br><span class="line">                         NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class nonmeta;</span><br><span class="line">    &#123;</span><br><span class="line">        mutex_locker_t lock(runtimeLock);</span><br><span class="line">        <span class="comment">//获取实例(类)对应的类对象，这个方法会根据传入的inst(也就是类),会判断是不是根元类等。最后返回一个类对象。</span></span><br><span class="line">        nonmeta = getMaybeUnrealizedNonMetaClass(cls, inst);</span><br><span class="line">        <span class="comment">// +initialize path should have realized nonmeta already</span></span><br><span class="line">        <span class="keyword">if</span> (!nonmeta-&gt;isRealized()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"nonmeta class %s (%p) unexpectedly not realized"</span>,</span><br><span class="line">                        nonmeta-&gt;nameForLogging(), nonmeta);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (<span class="keyword">typeof</span>(msg))objc_msgSend;</span><br><span class="line">    bool resolved = msg(nonmeta, SEL_resolveClassMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn't fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: method %c[%s %s] "</span></span><br><span class="line">                         <span class="string">"dynamically resolved to %p"</span>, </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn't add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: +[%s resolveClassMethod:%s] returned YES"</span></span><br><span class="line">                         <span class="string">", but no new implementation of %c[%s %s] was found"</span>,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>resolveClassMethod</code>总体流程与<code>resolveInstanceMethod</code>相仿，有个区别就是调用对应解析方法(resolveClassMethod/resolveInstanceMethod)的时候，类方法的动态解析要根据(类对象和元类)获取对应的类对象。然后在给对应的类对象发送动态解析的消息。  </p>
<p>还有一个疑问点，再来看<code>class_resolveMethod</code>这个方法的后半部分。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _class_resolveMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;   <span class="comment">//类对象或元类， 实例或类对象</span></span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">    ...    </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">            <span class="comment">//cls 为元类，该方法内部会调用：msgSend(cls,...),因此相当于到NSObject的根元类中调用resolveInstanceMethod。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们注意到在调用类方法的动态解析之后，又进行了一步判断：当前类没有处理，则进行到根元类的。为什么要这样设计呢？<br>我们首先来回归一个调用类方法的场景：<br>当我们调用一个类方法时，如果该类方法没有实现，那么最终会调用<code>NSObject<code>的实例方法。为什么要这样设计请参考文末关于isa答疑部分。<br>因此：<br>如果当前类没有对该类方法进行动态解析，那么也应该到<code>NSObject<code>去找，看是否有同名的示例方法，而对于示例方法的处理要是用<code>_class_resolveInstanceMethod</code>。</code></code></code></code></p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>在<code>lookUpImpOrForward</code>环节中，如果没有进行动态方法解析，那么最终会返回<code>_objc_msgForward_impcache</code>。我们可以在arm64的汇编中找到该函数的实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line"><span class="comment">// No stret specialization.</span></span><br><span class="line">b    __objc_msgForward</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENTRY __objc_msgForward</span><br><span class="line"></span><br><span class="line">adrp    x17, __objc_forward_handler@PAGE</span><br><span class="line">ldr    p17, [x17, __objc_forward_handler@PAGEOFF]</span><br><span class="line">TailCallFunctionPointer x17</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgForward</span><br></pre></td></tr></table></figure></p>
<p>通过上面汇编代码可知。转发的主要流程都是通过汇编来实现的。下面我们来还原真机的场景，首先加入<code>objc_msgForward_impcache</code>符号断点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libobjc.A.dylib`_objc_msgForward_impcache:</span><br><span class="line">-&gt;  0x199436560 &lt;+0&gt;:  b      0x199436580               ; _objc_msgForward</span><br></pre></td></tr></table></figure></p>
<p>step into<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libobjc.A.dylib`_objc_msgForward:</span><br><span class="line">-&gt;  0x199436580 &lt;+0&gt;:  adrp   x17, 294986</span><br><span class="line">    0x199436584 &lt;+4&gt;:  ldr    x17, [x17, #0xc50]</span><br><span class="line">    0x199436588 &lt;+8&gt;:  br     x17</span><br></pre></td></tr></table></figure></p>
<p>由于<code> ___forwarding___</code>内容过多，这里直接整理了一份流程图。<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/forward.png" alt="forward"><br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br></pre></td><td class="code"><pre><span class="line">CoreFoundation<span class="string">`___forwarding___:</span></span><br><span class="line"><span class="string">    //进行相关准备，比如获取cls，clsname等</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))</span></span><br><span class="line"><span class="string">    0x1997157ec &lt;+144&gt;:  bl     0x1994392e0               ; class_respondsToSelector</span></span><br><span class="line"><span class="string">    //和 0 比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令）</span></span><br><span class="line"><span class="string">    //如果无法进转发，则跳转到0x199715810：进行签名转发流程</span></span><br><span class="line"><span class="string">    0x1997157f0 &lt;+148&gt;:  cbz    w0, 0x199715810           ; &lt;+180&gt;</span></span><br><span class="line"><span class="string">    0x1997157f4 &lt;+152&gt;:  mov    x0, x21</span></span><br><span class="line"><span class="string">    0x1997157f8 &lt;+156&gt;:  mov    x1, x26</span></span><br><span class="line"><span class="string">    0x1997157fc &lt;+160&gt;:  mov    x2, x23</span></span><br><span class="line"><span class="string">    //msgsend(receiverClass, @selector(forwardingTargetForSelector:))</span></span><br><span class="line"><span class="string">-&gt;  0x199715800 &lt;+164&gt;:  bl     0x199436080               ; objc_msgSend</span></span><br><span class="line"><span class="string">    0x199715804 &lt;+168&gt;:  cmp    x0, #0x0                  ; =0x0 </span></span><br><span class="line"><span class="string">    0x199715808 &lt;+172&gt;:  ccmp   x0, x21, #0x4, ne</span></span><br><span class="line"><span class="string">    0x19971580c &lt;+176&gt;:  b.ne   0x199715acc               ; &lt;+880&gt;</span></span><br><span class="line"><span class="string">    //获取僵尸对象</span></span><br><span class="line"><span class="string">    0x199715810 &lt;+180&gt;:  adrp   x1, 137</span></span><br><span class="line"><span class="string">    0x199715814 &lt;+184&gt;:  add    x1, x1, #0x70e            ; =0x70e </span></span><br><span class="line"><span class="string">    0x199715818 &lt;+188&gt;:  mov    x0, x24</span></span><br><span class="line"><span class="string">    0x19971581c &lt;+192&gt;:  mov    w2, #0xa</span></span><br><span class="line"><span class="string">    0x199715820 &lt;+196&gt;:  bl     0x199773964               ; symbol stub for: cbRead.cold.2</span></span><br><span class="line"><span class="string">    //如果是僵尸对象，则跳转0x199715ba8：</span></span><br><span class="line"><span class="string">    0x199715824 &lt;+200&gt;:  cbz    w0, 0x199715ba8           ; &lt;+1100&gt;</span></span><br><span class="line"><span class="string">    0x199715828 &lt;+204&gt;:  adrp   x8, 227524</span></span><br><span class="line"><span class="string">    0x19971582c &lt;+208&gt;:  add    x24, x8, #0xb89           ; =0xb89 </span></span><br><span class="line"><span class="string">    0x199715830 &lt;+212&gt;:  mov    x0, x22</span></span><br><span class="line"><span class="string">    0x199715834 &lt;+216&gt;:  mov    x1, x24</span></span><br><span class="line"><span class="string">    //class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))</span></span><br><span class="line"><span class="string">    0x199715838 &lt;+220&gt;:  bl     0x1994392e0               ; class_respondsToSelector</span></span><br><span class="line"><span class="string">    //和 0 比较（Compare），如果结果为零（Zero）就转移</span></span><br><span class="line"><span class="string">    0x19971583c &lt;+224&gt;:  tbz    w0, #0x0, 0x199715bb8     ; &lt;+1116&gt;</span></span><br><span class="line"><span class="string">    0x199715840 &lt;+228&gt;:  mov    x0, x21</span></span><br><span class="line"><span class="string">    0x199715844 &lt;+232&gt;:  mov    x1, x24</span></span><br><span class="line"><span class="string">    0x199715848 &lt;+236&gt;:  mov    x2, x23</span></span><br><span class="line"><span class="string">    //msgsend(receiverClass, @selector(methodSignatureForSelector:))</span></span><br><span class="line"><span class="string">    0x19971584c &lt;+240&gt;:  bl     0x199436080               ; objc_msgSend</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">   //没有方法签名。跳转0x199715c24：SEL判断流程</span></span><br><span class="line"><span class="string">    0x199715850 &lt;+244&gt;:  cbz    x0, 0x199715c24           ; &lt;+1224&gt;</span></span><br><span class="line"><span class="string">    //存在方法签名</span></span><br><span class="line"><span class="string">    0x199715854 &lt;+248&gt;:  mov    x22, x0</span></span><br><span class="line"><span class="string">    0x199715858 &lt;+252&gt;:  adrp   x8, 227530</span></span><br><span class="line"><span class="string">    0x19971585c &lt;+256&gt;:  add    x1, x8, #0x3af            ; =0x3af </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //[methodSignature _frameDescriptor]</span></span><br><span class="line"><span class="string">    //返回一个struct，第一个成员为：struct NSMethodFrameArgInfo；</span></span><br><span class="line"><span class="string">    0x199715860 &lt;+260&gt;:  bl     0x199436080               ; objc_msgSend</span></span><br><span class="line"><span class="string">    0x199715864 &lt;+264&gt;:  mov    x24, x0</span></span><br><span class="line"><span class="string">    //读取返回值(methodSignature)的第一个成员。</span></span><br><span class="line"><span class="string">    0x199715868 &lt;+268&gt;:  ldr    x8, [x0]</span></span><br><span class="line"><span class="string">    0x19971586c &lt;+272&gt;:  ldrh   w8, [x8, #0x22]</span></span><br><span class="line"><span class="string">    0x199715870 &lt;+276&gt;:  ubfx   x8, x8, #6, #1</span></span><br><span class="line"><span class="string">    //判断是否是返回值是否是isStruct。</span></span><br><span class="line"><span class="string">    0x199715874 &lt;+280&gt;:  cmp    x8, x25</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //跳转到forwardingStackInvocation流程</span></span><br><span class="line"><span class="string">    0x199715878 &lt;+284&gt;:  b.eq   0x1997158cc               ; &lt;+368&gt;</span></span><br><span class="line"><span class="string">    0x19971587c &lt;+288&gt;:  mov    x0, x23</span></span><br><span class="line"><span class="string">    0x199715880 &lt;+292&gt;:  bl     0x19944dc44               ; sel_getName</span></span><br><span class="line"><span class="string">    0x199715884 &lt;+296&gt;:  ldr    x8, [x24]</span></span><br><span class="line"><span class="string">    0x199715888 &lt;+300&gt;:  ldrh   w8, [x8, #0x22]</span></span><br><span class="line"><span class="string">    0x19971588c &lt;+304&gt;:  adrp   x9, 128</span></span><br><span class="line"><span class="string">    0x199715890 &lt;+308&gt;:  add    x9, x9, #0x1c2            ; =0x1c2 </span></span><br><span class="line"><span class="string">    0x199715894 &lt;+312&gt;:  adrp   x10, 147</span></span><br><span class="line"><span class="string">    0x199715898 &lt;+316&gt;:  add    x10, x10, #0x1b4          ; =0x1b4 </span></span><br><span class="line"><span class="string">    0x19971589c &lt;+320&gt;:  tst    w8, #0x40</span></span><br><span class="line"><span class="string">    0x1997158a0 &lt;+324&gt;:  csel   x8, x10, x9, eq</span></span><br><span class="line"><span class="string">    0x1997158a4 &lt;+328&gt;:  cmp    x25, #0x0                 ; =0x0 </span></span><br><span class="line"><span class="string">    0x1997158a8 &lt;+332&gt;:  csel   x9, x10, x9, eq</span></span><br><span class="line"><span class="string">    0x1997158ac &lt;+336&gt;:  sub    sp, sp, #0x20             ; =0x20 </span></span><br><span class="line"><span class="string">    0x1997158b0 &lt;+340&gt;:  stp    x8, x9, [sp, #0x8]</span></span><br><span class="line"><span class="string">    0x1997158b4 &lt;+344&gt;:  str    x0, [sp]</span></span><br><span class="line"><span class="string">    0x1997158b8 &lt;+348&gt;:  adrp   x1, 249580</span></span><br><span class="line"><span class="string">    0x1997158bc &lt;+352&gt;:  add    x1, x1, #0xe10            ; =0xe10 </span></span><br><span class="line"><span class="string">    0x1997158c0 &lt;+356&gt;:  orr    w0, wzr, #0x4</span></span><br><span class="line"><span class="string">    0x1997158c4 &lt;+360&gt;:  bl     0x1996fe9d0               ; CFLog</span></span><br><span class="line"><span class="string">    0x1997158c8 &lt;+364&gt;:  add    sp, sp, #0x20             ; =0x20 </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    /* forwardStackInvocation */</span></span><br><span class="line"><span class="string">    0x1997158cc &lt;+368&gt;:  mov    x0, x21</span></span><br><span class="line"><span class="string">    0x1997158d0 &lt;+372&gt;:  bl     0x1994387e8               ; object_getClass</span></span><br><span class="line"><span class="string">    0x1997158d4 &lt;+376&gt;:  adrp   x8, 227530</span></span><br><span class="line"><span class="string">    0x1997158d8 &lt;+380&gt;:  add    x26, x8, #0x519           ; =0x519 </span></span><br><span class="line"><span class="string">    0x1997158dc &lt;+384&gt;:  mov    x1, x26</span></span><br><span class="line"><span class="string">    //是否实现 forwardStackInvocation</span></span><br><span class="line"><span class="string">    0x1997158e0 &lt;+388&gt;:  bl     0x1994392e0               ; class_respondsToSelector</span></span><br><span class="line"><span class="string">    //如果未实现，则跳转:0x1997159b4 forwardInvocation 环节</span></span><br><span class="line"><span class="string">    0x1997158e4 &lt;+392&gt;:  cbz    w0, 0x1997159b4           ; &lt;+600&gt;</span></span><br><span class="line"><span class="string">    0x1997158e8 &lt;+396&gt;:  adrp   x8, 294262</span></span><br><span class="line"><span class="string">    0x1997158ec &lt;+400&gt;:  ldr    x8, [x8, #0xa70]</span></span><br><span class="line"><span class="string">    0x1997158f0 &lt;+404&gt;:  cmn    x8, #0x1                  ; =0x1 </span></span><br><span class="line"><span class="string">    0x1997158f4 &lt;+408&gt;:  b.ne   0x199715b8c               ; &lt;+1072&gt;</span></span><br><span class="line"><span class="string">    0x1997158f8 &lt;+412&gt;:  adrp   x8, 284546</span></span><br><span class="line"><span class="string">    0x1997158fc &lt;+416&gt;:  ldr    x0, [x8, #0xe28]</span></span><br><span class="line"><span class="string">    0x199715900 &lt;+420&gt;:  adrp   x8, 227530</span></span><br><span class="line"><span class="string">    0x199715904 &lt;+424&gt;:  add    x1, x8, #0x532            ; =0x532 </span></span><br><span class="line"><span class="string">    0x199715908 &lt;+428&gt;:  mov    x2, x22</span></span><br><span class="line"><span class="string">    0x19971590c &lt;+432&gt;:  bl     0x199436080               ; objc_msgSend</span></span><br><span class="line"><span class="string">    0x199715910 &lt;+436&gt;:  mov    x25, x0</span></span><br><span class="line"><span class="string">    0x199715914 &lt;+440&gt;:  adrp   x8, 294262</span></span><br><span class="line"><span class="string">    0x199715918 &lt;+444&gt;:  ldr    x1, [x8, #0xa68]</span></span><br><span class="line"><span class="string">    0x19971591c &lt;+448&gt;:  add    x8, x1, #0xf              ; =0xf </span></span><br><span class="line"><span class="string">    0x199715920 &lt;+452&gt;:  and    x8, x8, #0xfffffffffffffff0</span></span><br><span class="line"><span class="string">    0x199715924 &lt;+456&gt;:  mov    x9, x8</span></span><br><span class="line"><span class="string">    0x199715928 &lt;+460&gt;:  adrp   x16, 249510</span></span><br><span class="line"><span class="string">    0x19971592c &lt;+464&gt;:  ldr    x16, [x16, #0xbb0]</span></span><br><span class="line"><span class="string">    0x199715930 &lt;+468&gt;:  blr    x16</span></span><br><span class="line"><span class="string">    0x199715934 &lt;+472&gt;:  mov    x9, sp</span></span><br><span class="line"><span class="string">    0x199715938 &lt;+476&gt;:  sub    x23, x9, x8</span></span><br><span class="line"><span class="string">    0x19971593c &lt;+480&gt;:  mov    sp, x23</span></span><br><span class="line"><span class="string">    0x199715940 &lt;+484&gt;:  mov    x0, x23</span></span><br><span class="line"><span class="string">    0x199715944 &lt;+488&gt;:  bl     0x1994200c0               ; __bzero</span></span><br><span class="line"><span class="string">    0x199715948 &lt;+492&gt;:  add    x8, x25, #0xf             ; =0xf </span></span><br><span class="line"><span class="string">    0x19971594c &lt;+496&gt;:  and    x8, x8, #0xfffffffffffffff0</span></span><br><span class="line"><span class="string">    0x199715950 &lt;+500&gt;:  mov    x9, x8</span></span><br><span class="line"><span class="string">    0x199715954 &lt;+504&gt;:  adrp   x16, 249510</span></span><br><span class="line"><span class="string">    0x199715958 &lt;+508&gt;:  ldr    x16, [x16, #0xbb0]</span></span><br><span class="line"><span class="string">    0x19971595c &lt;+512&gt;:  blr    x16</span></span><br><span class="line"><span class="string">    0x199715960 &lt;+516&gt;:  mov    x9, sp</span></span><br><span class="line"><span class="string">    0x199715964 &lt;+520&gt;:  sub    x27, x9, x8</span></span><br><span class="line"><span class="string">    0x199715968 &lt;+524&gt;:  mov    sp, x27</span></span><br><span class="line"><span class="string">    0x19971596c &lt;+528&gt;:  adrp   x8, 294262</span></span><br><span class="line"><span class="string">    0x199715970 &lt;+532&gt;:  ldr    x0, [x8, #0xa60]</span></span><br><span class="line"><span class="string">    0x199715974 &lt;+536&gt;:  mov    x1, x23</span></span><br><span class="line"><span class="string">    0x199715978 &lt;+540&gt;:  bl     0x19944b900               ; objc_constructInstance</span></span><br><span class="line"><span class="string">    0x19971597c &lt;+544&gt;:  adrp   x8, 227530</span></span><br><span class="line"><span class="string">    0x199715980 &lt;+548&gt;:  add    x1, x8, #0x551            ; =0x551 </span></span><br><span class="line"><span class="string">    0x199715984 &lt;+552&gt;:  mov    x0, x23</span></span><br><span class="line"><span class="string">    0x199715988 &lt;+556&gt;:  mov    x2, x22</span></span><br><span class="line"><span class="string">    0x19971598c &lt;+560&gt;:  mov    x3, x20</span></span><br><span class="line"><span class="string">    0x199715990 &lt;+564&gt;:  mov    x4, x27</span></span><br><span class="line"><span class="string">    0x199715994 &lt;+568&gt;:  mov    x5, x25</span></span><br><span class="line"><span class="string">    0x199715998 &lt;+572&gt;:  bl     0x199436080               ; objc_msgSend</span></span><br><span class="line"><span class="string">    0x19971599c &lt;+576&gt;:  mov    x0, x21</span></span><br><span class="line"><span class="string">    0x1997159a0 &lt;+580&gt;:  mov    x1, x26</span></span><br><span class="line"><span class="string">    0x1997159a4 &lt;+584&gt;:  mov    x2, x23</span></span><br><span class="line"><span class="string">    0x1997159a8 &lt;+588&gt;:  bl     0x199436080               ; objc_msgSend</span></span><br><span class="line"><span class="string">    0x1997159ac &lt;+592&gt;:  orr    w21, wzr, #0x1</span></span><br><span class="line"><span class="string">    0x1997159b0 &lt;+596&gt;:  b      0x199715a08               ; &lt;+684&gt;</span></span><br><span class="line"><span class="string">    /* forwardInvocation */ 环节</span></span><br><span class="line"><span class="string">    0x1997159b4 &lt;+600&gt;:  mov    x0, x21</span></span><br><span class="line"><span class="string">    0x1997159b8 &lt;+604&gt;:  bl     0x1994387e8               ; object_getClass</span></span><br><span class="line"><span class="string">    0x1997159bc &lt;+608&gt;:  adrp   x8, 227524</span></span><br><span class="line"><span class="string">    0x1997159c0 &lt;+612&gt;:  add    x25, x8, #0xba5           ; =0xba5 </span></span><br><span class="line"><span class="string">    0x1997159c4 &lt;+616&gt;:  mov    x1, x25</span></span><br><span class="line"><span class="string">    //是否响应 forwardInvocation</span></span><br><span class="line"><span class="string">    0x1997159c8 &lt;+620&gt;:  bl     0x1994392e0               ; class_respondsToSelector</span></span><br><span class="line"><span class="string">    0x1997159cc &lt;+624&gt;:  cbz    w0, 0x199715c00           ; &lt;+1188&gt;</span></span><br><span class="line"><span class="string">    0x1997159d0 &lt;+628&gt;:  adrp   x8, 284546</span></span><br><span class="line"><span class="string">    0x1997159d4 &lt;+632&gt;:  ldr    x0, [x8, #0xe28]</span></span><br><span class="line"><span class="string">    0x1997159d8 &lt;+636&gt;:  adrp   x8, 227530</span></span><br><span class="line"><span class="string">    0x1997159dc &lt;+640&gt;:  add    x1, x8, #0x4b2            ; =0x4b2 </span></span><br><span class="line"><span class="string">    0x1997159e0 &lt;+644&gt;:  mov    x2, x22</span></span><br><span class="line"><span class="string">    0x1997159e4 &lt;+648&gt;:  mov    x3, x20</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    0x1997159e8 &lt;+652&gt;:  bl     0x199436080               ; objc_msgSend</span></span><br><span class="line"><span class="string">    0x1997159ec &lt;+656&gt;:  mov    x23, x0</span></span><br><span class="line"><span class="string">    0x1997159f0 &lt;+660&gt;:  mov    x0, x21</span></span><br><span class="line"><span class="string">    0x1997159f4 &lt;+664&gt;:  mov    x1, x25</span></span><br><span class="line"><span class="string">    0x1997159f8 &lt;+668&gt;:  mov    x2, x23</span></span><br><span class="line"><span class="string">    //调用 forwardInvocation</span></span><br><span class="line"><span class="string">    0x1997159fc &lt;+672&gt;:  bl     0x199436080               ; objc_msgSend</span></span><br><span class="line"><span class="string">    0x199715a00 &lt;+676&gt;:  mov    x25, #0x0</span></span><br><span class="line"><span class="string">    0x199715a04 &lt;+680&gt;:  mov    w21, #0x0</span></span><br><span class="line"><span class="string">    0x199715a08 &lt;+684&gt;:  ldrb   w8, [x23, #0x34]</span></span><br><span class="line"><span class="string">    0x199715a0c &lt;+688&gt;:  cbz    w8, 0x199715a44           ; &lt;+744&gt;</span></span><br><span class="line"><span class="string">    0x199715a10 &lt;+692&gt;:  ldr    x8, [x24]</span></span><br><span class="line"><span class="string">    0x199715a14 &lt;+696&gt;:  ldrb   w9, [x8, #0x22]</span></span><br><span class="line"><span class="string">    0x199715a18 &lt;+700&gt;:  tbz    w9, #0x7, 0x199715a44     ; &lt;+744&gt;</span></span><br><span class="line"><span class="string">    0x199715a1c &lt;+704&gt;:  ldr    x9, [x23, #0x8]</span></span><br><span class="line"><span class="string">    0x199715a20 &lt;+708&gt;:  ldr    w10, [x8, #0x1c]</span></span><br><span class="line"><span class="string">    0x199715a24 &lt;+712&gt;:  add    x11, x20, x10</span></span><br><span class="line"><span class="string">    0x199715a28 &lt;+716&gt;:  ldrb   w12, [x8, #0x20]</span></span><br><span class="line"><span class="string">    0x199715a2c &lt;+720&gt;:  add    x9, x9, x10</span></span><br><span class="line"><span class="string">    0x199715a30 &lt;+724&gt;:  ldr    x0, [x11, x12]</span></span><br><span class="line"><span class="string">    0x199715a34 &lt;+728&gt;:  ldr    x1, [x9, x12]</span></span><br><span class="line"><span class="string">    0x199715a38 &lt;+732&gt;:  ldr    x8, [x8]</span></span><br><span class="line"><span class="string">    0x199715a3c &lt;+736&gt;:  ldr    w2, [x8, #0x10]</span></span><br><span class="line"><span class="string">    0x199715a40 &lt;+740&gt;:  bl     0x1997731d8               ; symbol stub for: -[NSDictionary getKeys:].cold.1</span></span><br><span class="line"><span class="string">    0x199715a44 &lt;+744&gt;:  adrp   x8, 227530</span></span><br><span class="line"><span class="string">    0x199715a48 &lt;+748&gt;:  add    x1, x8, #0x454            ; =0x454 </span></span><br><span class="line"><span class="string">    0x199715a4c &lt;+752&gt;:  mov    x0, x22</span></span><br><span class="line"><span class="string">    0x199715a50 &lt;+756&gt;:  bl     0x199436080               ; objc_msgSend</span></span><br><span class="line"><span class="string">    0x199715a54 &lt;+760&gt;:  ldrb   w8, [x0]</span></span><br><span class="line"><span class="string">    0x199715a58 &lt;+764&gt;:  cmp    w8, #0x76                 ; =0x76 </span></span><br><span class="line"><span class="string">    0x199715a5c &lt;+768&gt;:  b.eq   0x199715a74               ; &lt;+792&gt;</span></span><br><span class="line"><span class="string">    0x199715a60 &lt;+772&gt;:  cmp    w8, #0x56                 ; =0x56 </span></span><br><span class="line"><span class="string">    0x199715a64 &lt;+776&gt;:  b.ne   0x199715a8c               ; &lt;+816&gt;</span></span><br><span class="line"><span class="string">    0x199715a68 &lt;+780&gt;:  ldrb   w8, [x0, #0x1]</span></span><br><span class="line"><span class="string">    0x199715a6c &lt;+784&gt;:  cmp    w8, #0x76                 ; =0x76 </span></span><br><span class="line"><span class="string">    0x199715a70 &lt;+788&gt;:  b.ne   0x199715a8c               ; &lt;+816&gt;</span></span><br><span class="line"><span class="string">    0x199715a74 &lt;+792&gt;:  cbz    w21, 0x199715a80          ; &lt;+804&gt;</span></span><br><span class="line"><span class="string">    0x199715a78 &lt;+796&gt;:  mov    x0, x23</span></span><br><span class="line"><span class="string">    0x199715a7c &lt;+800&gt;:  bl     0x199454130               ; objc_release</span></span><br><span class="line"><span class="string">    0x199715a80 &lt;+804&gt;:  adrp   x20, 284552</span></span><br><span class="line"><span class="string">    0x199715a84 &lt;+808&gt;:  add    x20, x20, #0x150          ; =0x150 </span></span><br><span class="line"><span class="string">    0x199715a88 &lt;+812&gt;:  b      0x199715b50               ; &lt;+1012&gt;</span></span><br><span class="line"><span class="string">    0x199715a8c &lt;+816&gt;:  ldr    x20, [x23, #0x10]</span></span><br><span class="line"><span class="string">    0x199715a90 &lt;+820&gt;:  cbz    w21, 0x199715b50          ; &lt;+1012&gt;</span></span><br><span class="line"><span class="string">    0x199715a94 &lt;+824&gt;:  adrp   x8, 284546</span></span><br><span class="line"><span class="string">    0x199715a98 &lt;+828&gt;:  ldr    x0, [x8, #0xcd8]</span></span><br><span class="line"><span class="string">    0x199715a9c &lt;+832&gt;:  adrp   x8, 227525</span></span><br><span class="line"><span class="string">    0x199715aa0 &lt;+836&gt;:  add    x1, x8, #0xa93            ; =0xa93 </span></span><br><span class="line"><span class="string">    0x199715aa4 &lt;+840&gt;:  mov    x2, x20</span></span><br><span class="line"><span class="string">    0x199715aa8 &lt;+844&gt;:  mov    x3, x25</span></span><br><span class="line"><span class="string">    0x199715aac &lt;+848&gt;:  bl     0x199436080               ; objc_msgSend</span></span><br><span class="line"><span class="string">    0x199715ab0 &lt;+852&gt;:  adrp   x8, 227524</span></span><br><span class="line"><span class="string">    0x199715ab4 &lt;+856&gt;:  add    x1, x8, #0x9f6            ; =0x9f6 </span></span><br><span class="line"><span class="string">    0x199715ab8 &lt;+860&gt;:  bl     0x199436080               ; objc_msgSend</span></span><br><span class="line"><span class="string">    0x199715abc &lt;+864&gt;:  mov    x20, x0</span></span><br><span class="line"><span class="string">    0x199715ac0 &lt;+868&gt;:  mov    x0, x23</span></span><br><span class="line"><span class="string">    0x199715ac4 &lt;+872&gt;:  bl     0x199454130               ; objc_release</span></span><br><span class="line"><span class="string">    0x199715ac8 &lt;+876&gt;:  b      0x199715b50               ; &lt;+1012&gt;</span></span><br><span class="line"><span class="string">    0x199715acc &lt;+880&gt;:  tbz    x0, #0x3f, 0x199715af8    ; &lt;+924&gt;</span></span><br><span class="line"><span class="string">    0x199715ad0 &lt;+884&gt;:  adrp   x8, 249510</span></span><br><span class="line"><span class="string">    0x199715ad4 &lt;+888&gt;:  ldr    x8, [x8, #0xcf8]</span></span><br><span class="line"><span class="string">    0x199715ad8 &lt;+892&gt;:  ldr    x8, [x8]</span></span><br><span class="line"><span class="string">    0x199715adc &lt;+896&gt;:  eor    x8, x8, x0</span></span><br><span class="line"><span class="string">    0x199715ae0 &lt;+900&gt;:  ubfx   x9, x8, #60, #3</span></span><br><span class="line"><span class="string">    0x199715ae4 &lt;+904&gt;:  cmp    x9, #0x7                  ; =0x7 </span></span><br><span class="line"><span class="string">    0x199715ae8 &lt;+908&gt;:  ubfx   x8, x8, #52, #8</span></span><br><span class="line"><span class="string">    0x199715aec &lt;+912&gt;:  add    x8, x8, #0x8              ; =0x8 </span></span><br><span class="line"><span class="string">    0x199715af0 &lt;+916&gt;:  csel   x8, x9, x8, ne</span></span><br><span class="line"><span class="string">    0x199715af4 &lt;+920&gt;:  cbz    w8, 0x199715b04           ; &lt;+936&gt;</span></span><br><span class="line"><span class="string">    0x199715af8 &lt;+924&gt;:  str    x0, [x20]</span></span><br><span class="line"><span class="string">    0x199715afc &lt;+928&gt;:  mov    x20, #0x0</span></span><br><span class="line"><span class="string">    0x199715b00 &lt;+932&gt;:  b      0x199715b50               ; &lt;+1012&gt;</span></span><br><span class="line"><span class="string">    0x199715b04 &lt;+936&gt;:  mov    x21, x0</span></span><br><span class="line"><span class="string">    0x199715b08 &lt;+940&gt;:  adrp   x8, 294261</span></span><br><span class="line"><span class="string">    0x199715b0c &lt;+944&gt;:  ldrb   w8, [x8, #0xe78]</span></span><br><span class="line"><span class="string">    0x199715b10 &lt;+948&gt;:  tbnz   w8, #0x4, 0x199715c94     ; &lt;+1336&gt;</span></span><br><span class="line"><span class="string">    0x199715b14 &lt;+952&gt;:  mov    x0, x21</span></span><br><span class="line"><span class="string">    0x199715b18 &lt;+956&gt;:  bl     0x19971e5c0               ; getAtomTarget</span></span><br><span class="line"><span class="string">    0x199715b1c &lt;+960&gt;:  mov    x22, x0</span></span><br><span class="line"><span class="string">    0x199715b20 &lt;+964&gt;:  str    x0, [x20]</span></span><br><span class="line"><span class="string">    0x199715b24 &lt;+968&gt;:  adrp   x0, 249510</span></span><br><span class="line"><span class="string">    0x199715b28 &lt;+972&gt;:  ldr    x0, [x0, #0xd00]</span></span><br><span class="line"><span class="string">    0x199715b2c &lt;+976&gt;:  mov    w4, #0x0</span></span><br><span class="line"><span class="string">    0x199715b30 &lt;+980&gt;:  mov    x1, x20</span></span><br><span class="line"><span class="string">    0x199715b34 &lt;+984&gt;:  mov    x2, x20</span></span><br><span class="line"><span class="string">    0x199715b38 &lt;+988&gt;:  orr    w3, wzr, #0x400</span></span><br><span class="line"><span class="string">    0x199715b3c &lt;+992&gt;:  bl     0x199717b80               ; __invoking___</span></span><br><span class="line"><span class="string">    0x199715b40 &lt;+996&gt;:  ldr    x8, [x20]</span></span><br><span class="line"><span class="string">    0x199715b44 &lt;+1000&gt;: cmp    x8, x22</span></span><br><span class="line"><span class="string">    0x199715b48 &lt;+1004&gt;: b.ne   0x199715b50               ; &lt;+1012&gt;</span></span><br><span class="line"><span class="string">    0x199715b4c &lt;+1008&gt;: str    x21, [x20]</span></span><br><span class="line"><span class="string">    0x199715b50 &lt;+1012&gt;: ldur   x8, [x29, #-0x58]</span></span><br><span class="line"><span class="string">    0x199715b54 &lt;+1016&gt;: adrp   x9, 249510</span></span><br><span class="line"><span class="string">    0x199715b58 &lt;+1020&gt;: ldr    x9, [x9, #0xbc8]</span></span><br><span class="line"><span class="string">    0x199715b5c &lt;+1024&gt;: ldr    x9, [x9]</span></span><br><span class="line"><span class="string">    0x199715b60 &lt;+1028&gt;: cmp    x9, x8</span></span><br><span class="line"><span class="string">    0x199715b64 &lt;+1032&gt;: b.ne   0x199715ba4               ; &lt;+1096&gt;</span></span><br><span class="line"><span class="string">    0x199715b68 &lt;+1036&gt;: mov    x0, x20</span></span><br><span class="line"><span class="string">    0x199715b6c &lt;+1040&gt;: sub    sp, x29, #0x50            ; =0x50 </span></span><br><span class="line"><span class="string">    0x199715b70 &lt;+1044&gt;: ldp    x29, x30, [sp, #0x50]</span></span><br><span class="line"><span class="string">    0x199715b74 &lt;+1048&gt;: ldp    x20, x19, [sp, #0x40]</span></span><br><span class="line"><span class="string">    0x199715b78 &lt;+1052&gt;: ldp    x22, x21, [sp, #0x30]</span></span><br><span class="line"><span class="string">    0x199715b7c &lt;+1056&gt;: ldp    x24, x23, [sp, #0x20]</span></span><br><span class="line"><span class="string">    0x199715b80 &lt;+1060&gt;: ldp    x26, x25, [sp, #0x10]</span></span><br><span class="line"><span class="string">    0x199715b84 &lt;+1064&gt;: ldp    x28, x27, [sp], #0x60</span></span><br><span class="line"><span class="string">    0x199715b88 &lt;+1068&gt;: ret    </span></span><br><span class="line"><span class="string">    0x199715b8c &lt;+1072&gt;: adrp   x0, 294262</span></span><br><span class="line"><span class="string">    0x199715b90 &lt;+1076&gt;: add    x0, x0, #0xa70            ; =0xa70 </span></span><br><span class="line"><span class="string">    0x199715b94 &lt;+1080&gt;: adrp   x1, 249532</span></span><br><span class="line"><span class="string">    0x199715b98 &lt;+1084&gt;: add    x1, x1, #0x4d0            ; =0x4d0 </span></span><br><span class="line"><span class="string">    0x199715b9c &lt;+1088&gt;: bl     0x199772c5c               ; symbol stub for: -[NSMutableSet removeObjectsInOrderedSet:range:].cold.1</span></span><br><span class="line"><span class="string">    0x199715ba0 &lt;+1092&gt;: b      0x1997158f8               ; &lt;+412&gt;</span></span><br><span class="line"><span class="string">    0x199715ba4 &lt;+1096&gt;: bl     0x19935a190               ; __stack_chk_fail</span></span><br><span class="line"><span class="string">    0x199715ba8 &lt;+1100&gt;: mov    x0, x21</span></span><br><span class="line"><span class="string">    0x199715bac &lt;+1104&gt;: mov    x1, x24</span></span><br><span class="line"><span class="string">    0x199715bb0 &lt;+1108&gt;: mov    x2, x23</span></span><br><span class="line"><span class="string">    0x199715bb4 &lt;+1112&gt;: bl     0x19976d908               ; ___forwarding___.cold.2</span></span><br><span class="line"><span class="string">    //获得父类</span></span><br><span class="line"><span class="string">    0x199715bb8 &lt;+1116&gt;: mov    x0, x22</span></span><br><span class="line"><span class="string">    0x199715bbc &lt;+1120&gt;: bl     0x199439370               ; class_getSuperclass</span></span><br><span class="line"><span class="string">    //把父类 存入 x22</span></span><br><span class="line"><span class="string">    0x199715bc0 &lt;+1124&gt;: mov    x22, x0     </span></span><br><span class="line"><span class="string">    0x199715bc4 &lt;+1128&gt;: mov    x0, x21</span></span><br><span class="line"><span class="string">    //获得类名</span></span><br><span class="line"><span class="string">    0x199715bc8 &lt;+1132&gt;: bl     0x1994389a0               ; object_getClassName</span></span><br><span class="line"><span class="string">    //类名存入x20</span></span><br><span class="line"><span class="string">    0x199715bcc &lt;+1136&gt;: mov    x20, x0</span></span><br><span class="line"><span class="string">    //父类如果不为空则跳转0x199715c0c：打印log *** NSForwarding: warning: object %p of class '%s' does not implement methodSignatureForSelector: -- trouble ahead</span></span><br><span class="line"><span class="string">    0x199715bd0 &lt;+1140&gt;: cbnz   x22, 0x199715c0c          ; &lt;+1200&gt;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //如果没有父类，和的当前类名及日志信息</span></span><br><span class="line"><span class="string">    0x199715bd4 &lt;+1144&gt;: mov    x0, x21     </span></span><br><span class="line"><span class="string">    0x199715bd8 &lt;+1148&gt;: bl     0x1994389a0               ; object_getClassName</span></span><br><span class="line"><span class="string">    0x199715bdc &lt;+1152&gt;: sub    sp, sp, #0x20             ; =0x20 </span></span><br><span class="line"><span class="string">    0x199715be0 &lt;+1156&gt;: stp    x20, x0, [sp, #0x8]</span></span><br><span class="line"><span class="string">    0x199715be4 &lt;+1160&gt;: str    x21, [sp]</span></span><br><span class="line"><span class="string">    0x199715be8 &lt;+1164&gt;: adrp   x1, 249580</span></span><br><span class="line"><span class="string">    0x199715bec &lt;+1168&gt;: add    x1, x1, #0xd90            ; =0xd90 </span></span><br><span class="line"><span class="string">    0x199715bf0 &lt;+1172&gt;: orr    w0, wzr, #0x4</span></span><br><span class="line"><span class="string">    //log *** NSForwarding: warning: object %p of class '%s' does not implement methodSignatureForSelector: -- did you forget to declare the superclass of '%s'</span></span><br><span class="line"><span class="string">    0x199715bf4 &lt;+1176&gt;: bl     0x1996fe9d0               ; CFLog</span></span><br><span class="line"><span class="string">    0x199715bf8 &lt;+1180&gt;: add    sp, sp, #0x20             ; =0x20 </span></span><br><span class="line"><span class="string">    //在看sel 是不是注册过，如果没有也要打印下</span></span><br><span class="line"><span class="string">    0x199715bfc &lt;+1184&gt;: b      0x199715c24               ; &lt;+1224&gt;</span></span><br><span class="line"><span class="string">    0x199715c00 &lt;+1188&gt;: add    x0, x19, #0x8             ; =0x8 </span></span><br><span class="line"><span class="string">    0x199715c04 &lt;+1192&gt;: mov    x1, x21</span></span><br><span class="line"><span class="string">    0x199715c08 &lt;+1196&gt;: bl     0x19976d994               ; ___forwarding___.cold.4</span></span><br><span class="line"><span class="string">    /* CFlog 日志 */</span></span><br><span class="line"><span class="string">    0x199715c0c &lt;+1200&gt;: stp    x21, x20, [sp, #-0x10]!</span></span><br><span class="line"><span class="string">    0x199715c10 &lt;+1204&gt;: adrp   x1, 249580</span></span><br><span class="line"><span class="string">    0x199715c14 &lt;+1208&gt;: add    x1, x1, #0xdb0            ; =0xdb0 </span></span><br><span class="line"><span class="string">    0x199715c18 &lt;+1212&gt;: orr    w0, wzr, #0x4</span></span><br><span class="line"><span class="string">    0x199715c1c &lt;+1216&gt;: bl     0x1996fe9d0               ; CFLog</span></span><br><span class="line"><span class="string">    0x199715c20 &lt;+1220&gt;: add    sp, sp, #0x10             ; =0x10 </span></span><br><span class="line"><span class="string">    //获取0x199715c24 开始为 获取注册的 SEL 过程</span></span><br><span class="line"><span class="string">    0x199715c24 &lt;+1224&gt;: mov    x0, x23</span></span><br><span class="line"><span class="string">    0x199715c28 &lt;+1228&gt;: bl     0x19944dc44               ; sel_getName</span></span><br><span class="line"><span class="string">    0x199715c2c &lt;+1232&gt;: mov    x20, x0</span></span><br><span class="line"><span class="string">    0x199715c30 &lt;+1236&gt;: bl     0x19944dda4               ; sel_getUid</span></span><br><span class="line"><span class="string">    // 是否注册过</span></span><br><span class="line"><span class="string">    0x199715c34 &lt;+1240&gt;: cmp    x0, x23</span></span><br><span class="line"><span class="string">    // 如果注册过，则进行doesNotRecognizeSelector流程。</span></span><br><span class="line"><span class="string">    0x199715c38 &lt;+1244&gt;: b.eq   0x199715c5c               ; &lt;+1280&gt;</span></span><br><span class="line"><span class="string">    //进行 异常log selector "xxx" for message "xxx" does not match selector known to Objective C runtime  </span></span><br><span class="line"><span class="string">    0x199715c3c &lt;+1248&gt;: sub    sp, sp, #0x20             ; =0x20 </span></span><br><span class="line"><span class="string">    0x199715c40 &lt;+1252&gt;: stp    x20, x0, [sp, #0x8]</span></span><br><span class="line"><span class="string">    0x199715c44 &lt;+1256&gt;: str    x23, [sp]</span></span><br><span class="line"><span class="string">    0x199715c48 &lt;+1260&gt;: adrp   x1, 249580</span></span><br><span class="line"><span class="string">    0x199715c4c &lt;+1264&gt;: add    x1, x1, #0xdd0            ; =0xdd0 </span></span><br><span class="line"><span class="string">    0x199715c50 &lt;+1268&gt;: orr    w0, wzr, #0x4</span></span><br><span class="line"><span class="string">    0x199715c54 &lt;+1272&gt;: bl     0x1996fe9d0               ; CFLog</span></span><br><span class="line"><span class="string">    0x199715c58 &lt;+1276&gt;: add    sp, sp, #0x20             ; =0x20 </span></span><br><span class="line"><span class="string">    //下面为调用doesNotRecognizeSelector 流程</span></span><br><span class="line"><span class="string">    0x199715c5c &lt;+1280&gt;: mov    x0, x21</span></span><br><span class="line"><span class="string">    0x199715c60 &lt;+1284&gt;: bl     0x1994387e8               ; object_getClass</span></span><br><span class="line"><span class="string">    0x199715c64 &lt;+1288&gt;: adrp   x8, 227524</span></span><br><span class="line"><span class="string">    0x199715c68 &lt;+1292&gt;: add    x20, x8, #0xb4b           ; =0xb4b </span></span><br><span class="line"><span class="string">    0x199715c6c &lt;+1296&gt;: mov    x1, x20</span></span><br><span class="line"><span class="string">    //class_respondsToSelector(receiverClass, doesNotRecognizeSelector:)</span></span><br><span class="line"><span class="string">    0x199715c70 &lt;+1300&gt;: bl     0x1994392e0               ; class_respondsToSelector</span></span><br><span class="line"><span class="string">    //object "xxx" of class "xxx" does not implement forwardInvocation:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    0x199715c74 &lt;+1304&gt;: cbz    w0, 0x199715c8c           ; &lt;+1328&gt;</span></span><br><span class="line"><span class="string">    0x199715c78 &lt;+1308&gt;: mov    x0, x21</span></span><br><span class="line"><span class="string">    0x199715c7c &lt;+1312&gt;: mov    x1, x20</span></span><br><span class="line"><span class="string">    0x199715c80 &lt;+1316&gt;: mov    x2, x23</span></span><br><span class="line"><span class="string">    //msgSend(receiverClass, doesNotRecognizeSelector:)</span></span><br><span class="line"><span class="string">    0x199715c84 &lt;+1320&gt;: bl     0x199436080               ; objc_msgSend</span></span><br><span class="line"><span class="string">    0x199715c88 &lt;+1324&gt;: brk    #0x1</span></span><br><span class="line"><span class="string">    0x199715c8c &lt;+1328&gt;: mov    x0, x21</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //object "xxx" of class "xxx" does not implement forwardInvocation:</span></span><br><span class="line"><span class="string">    0x199715c90 &lt;+1332&gt;: bl     0x19976d964               ; ___forwarding___.cold.3 </span></span><br><span class="line"><span class="string">    0x199715c94 &lt;+1336&gt;: bl     0x19976d8f8               ; ___forwarding___.cold.1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>现在我们来回答第二个问题：消息的机制是什么？<br>消息机制：向<code>target</code>发送<code>消息</code>，<code>动态寻找</code>函数<code>实现地址</code>并调用的过程。<br>target：receiver( class / instance )。<br>消息：selector。<br>动态寻找：动态解析+消息传递(父类)+消息转发。<br>实现地址：IMP。  </p>
<p>其实就是<code>msgSend(receiver, sel,…)</code>的一套完整流程。这一套流程也是来自与SmallTalk。</p>
<h2 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h2><h3 id="isa-如何理解一切皆“是”对象？"><a href="#isa-如何理解一切皆“是”对象？" class="headerlink" title="isa(如何理解一切皆“是”对象？)"></a>isa(如何理解一切皆“是”对象？)</h3><p>“对象”都是相对而言的，在<code>Objc</code>中使用<code>isa</code>来实现。实现万物皆对象，有个特殊的问题，就是根对象如何处理？<br>问：如果根元类的isa 为什么要指向自己？指向nil行不行，指向其他行不行，根元类的supercls为什么要指向根类(NSObject)?<br>从开篇提出的第一个问题的回答我们知道，isa是用来实现“串联起对象，类，类对象”。同时也实现构建了类方法，实例方法。下面来看一个例子。<br>[objc doSomething]的本质是？  </p>
<table>
<thead>
<tr>
<th>objc</th>
<th>是什么(isa)</th>
<th>在哪里找方法 </th>
</tr>
</thead>
<tbody>
<tr>
<td> 实例</td>
<td>类</td>
<td>类 </td>
</tr>
<tr>
<td> 类</td>
<td>元类</td>
<td>元类 </td>
</tr>
<tr>
<td> 元类</td>
<td>根元类</td>
<td>根元类 </td>
</tr>
<tr>
<td> 根元类</td>
<td>？</td>
<td>？ </td>
</tr>
</tbody>
</table>
<p>objc 是根元类，此时会出现一个问题，即：去哪里找这doSomething。那么objc是如何解决的呢？<br>首先一定不能为nil，如果为nil，就意味着 objc 是无意义(不知是什么类型?)的，其次无法进行方法调用，那么如果指向其他可以么？<br>其实是可以的，但是没有指向自身更好。<br>根元类的方法只能存在isa 指向的那个类(比如NSObject)，则势必会造成入侵(NSObject类要除了要存储实例对象的方法，还要存类对象)。对象的结构(isa，class_data_bits_t等)定义也会变得混乱。<br>附上一张<code>isa</code>指向图<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/oc_summarise/01F0F5A1-C5C7-49A2-BA68-4802D5884A8B.png" alt="isa"></p>
<h3 id="supercls"><a href="#supercls" class="headerlink" title="supercls"></a>supercls</h3><p>为什么所有的类把<code>NSObject</code>作为根父类(间接或直接继承NSObject)？(为什么根元类的父类为<code>NSObject</code>)。<br>答：NSObject提供了运行时，OOP对象模型，以及内存管理相关的基本能力， 对象通过继承 NSObject ，才可以获得上述功能。   </p>
<p>那么如何创建一个不继承NSObject 的类呢，或者说跟NSObject同级的类？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_root_class))</span><br><span class="line">@interface MyClass</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation MyClass</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>这个类没有任何功能，都需要开发者自己实现。</p>
<h3 id="消息转发-1"><a href="#消息转发-1" class="headerlink" title="消息转发"></a>消息转发</h3><p>为什么需要消息转发这样的机制？<br>这里引用smalltalk的一段话。</p>
<blockquote>
<p>When a message is sent to an object, a method will be selected and executed. Since we cannot know, in general, the class of the object until run-time, the method cannot be selected until the message is actually sent. This is called “dynamic binding”。  </p>
</blockquote>
<p>因为<code>objc</code>的方法实现地址并不是直接由编译器来确定的(是要运行时经过msgsend在ro里面去查找)。因此是不能直接在编译阶段就确定一个方法是否是有实现的，所以需要实现一个类似“编译器方法检查”的运行时机制。  </p>
<p>那么<code>objc</code>怎么实现这个机制呢？<br>这个也简单，编译器在发现方法不存在时，会直接报错，那运行时也可以这样做。也就是<code>doesNotRecognizeSelector</code>。在smalltalk中称为<code>doesNotUnderstand</code>或<code>Message-Not-Understood</code>。</p>
<p>不过显然<code>objc</code>考虑的更周全，虽然要抛出<code>doesNotRecognizeSelector</code>，但是由于其<code>dynamic binding</code>的特性，使得在抛出异常之前，<code>objc</code>提供了另外的消息处理机会。</p>
<p>也是“消息传递”和“动态”的一种思想提现。</p>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p>Smalltalk之父或者说面向对象之父（之一）的Alan Kay曾写过：</p>
<blockquote>
<p>I’m sorry that I long ago coined the term “objects” for this topic because it gets many people to focus on the lesser idea. The big idea is “messaging” - that is what the kernal of Smalltalk/Squeak is all about.  </p>
</blockquote>
<p> The big idea is “messaging”！！</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://web.cecs.pdx.edu/~harry/musings/SmalltalkOverview.html#Message%20Sending%20Syntax" target="_blank" rel="noopener">Smalltalk overview</a><br><a href="https://zh.wikipedia.org/wiki/Objective-C#%E8%A8%8A%E6%81%AF%E5%82%B3%E9%81%9E" target="_blank" rel="noopener">Objective-C</a><br><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1" target="_blank" rel="noopener">runtime</a></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/底层/" rel="tag"># 底层</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/29/2019年度总结/" rel="next" title="2019年度总结">
                <i class="fa fa-chevron-left"></i> 2019年度总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/01/10/从llvm看machO/" rel="prev" title="从LLVM看MachO">
                从LLVM看MachO <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/profile/avatar.png" alt="yfeii">
            
              <p class="site-author-name" itemprop="name">yfeii</p>
              <div class="site-description motion-element" itemprop="description">邮箱1486662452@qq.com，有问题欢迎留言评论或邮件</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">29</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#背景"><span class="nav-number">1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的结构"><span class="nav-number">2.</span> <span class="nav-text">类的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#objc-object"><span class="nav-number">2.1.</span> <span class="nav-text">objc_object</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#isa-t"><span class="nav-number">2.1.1.</span> <span class="nav-text">isa_t</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实验"><span class="nav-number">2.1.2.</span> <span class="nav-text">实验</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他"><span class="nav-number">2.1.3.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#objc-class"><span class="nav-number">2.2.</span> <span class="nav-text">objc_class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache-t"><span class="nav-number">2.3.</span> <span class="nav-text">cache_t</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初步验证"><span class="nav-number">2.3.1.</span> <span class="nav-text">初步验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cache-fill-nolock"><span class="nav-number">2.3.2.</span> <span class="nav-text">cache_fill_nolock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reallocate"><span class="nav-number">2.3.3.</span> <span class="nav-text">reallocate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#expend"><span class="nav-number">2.3.4.</span> <span class="nav-text">expend</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">2.3.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class-data-bits-t"><span class="nav-number">2.4.</span> <span class="nav-text">class_data_bits_t</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#class-ro-t"><span class="nav-number">2.4.1.</span> <span class="nav-text">class_ro_t</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#class-rw-t"><span class="nav-number">2.4.2.</span> <span class="nav-text">class_rw_t</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#realizeClass"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">realizeClass</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#methodizeClass"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">methodizeClass</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-1"><span class="nav-number">2.4.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息查找"><span class="nav-number">3.</span> <span class="nav-text">消息查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#msgSend"><span class="nav-number">3.1.</span> <span class="nav-text">msgSend</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#伪代码"><span class="nav-number">3.1.1.</span> <span class="nav-text">伪代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-msgSend-uncached"><span class="nav-number">3.1.2.</span> <span class="nav-text">objc_msgSend_uncached</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lookUpImpOrForward"><span class="nav-number">3.2.</span> <span class="nav-text">lookUpImpOrForward</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cache-getImp"><span class="nav-number">3.2.1.</span> <span class="nav-text">cache_getImp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getMethodNoSuper-nolock"><span class="nav-number">3.2.2.</span> <span class="nav-text">getMethodNoSuper_nolock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#search-method-list"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">search_method_list</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#findMethodInSortedMethodList"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">findMethodInSortedMethodList</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#log-and-fill-cache"><span class="nav-number">3.2.3.</span> <span class="nav-text">log_and_fill_cache</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态解析-amp-消息转发"><span class="nav-number">4.</span> <span class="nav-text">动态解析&amp;消息转发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态解析"><span class="nav-number">4.1.</span> <span class="nav-text">动态解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实例方法的动态解析"><span class="nav-number">4.1.1.</span> <span class="nav-text">实例方法的动态解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类方法的动态解析"><span class="nav-number">4.1.2.</span> <span class="nav-text">类方法的动态解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息转发"><span class="nav-number">4.2.</span> <span class="nav-text">消息转发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-2"><span class="nav-number">4.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#why"><span class="nav-number">5.</span> <span class="nav-text">why?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#isa-如何理解一切皆“是”对象？"><span class="nav-number">5.1.</span> <span class="nav-text">isa(如何理解一切皆“是”对象？)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#supercls"><span class="nav-number">5.2.</span> <span class="nav-text">supercls</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息转发-1"><span class="nav-number">5.3.</span> <span class="nav-text">消息转发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他-1"><span class="nav-number">5.4.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-number">6.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yfeii</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/affix.js?v=7.1.1"></script>

  <script src="/js/schemes/pisces.js?v=7.1.1"></script>



  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  
  

<script>
  var disqus_config = function() {
    this.page.url = "http://yfeii.github.io/2019/12/30/Objective-C底层汇总/";
    this.page.identifier = "2019/12/30/Objective-C底层汇总/";
    this.page.title = 'Objective-C底层汇总';
    };
  function loadComments() {
    var d = document, s = d.createElement('script');
    s.src = 'https://https-devyang-space.disqus.com/embed.js';
    s.setAttribute('data-timestamp', '' + +new Date());
    (d.head || d.body).appendChild(s);
  }
  
    $(function() {
      var offsetTop = $('#comments').offset().top - $(window).height();
      if (offsetTop <= 0) {
        // load directly when there's no a scrollbar
        loadComments();
      } else {
        $(window).on('scroll.disqus_scroll', function() {
          // offsetTop may changes because of manually resizing browser window or lazy loading images.
          var offsetTop = $('#comments').offset().top - $(window).height();
          var scrollTop = $(window).scrollTop();

          // pre-load comments a bit? (margin or anything else)
          if (offsetTop - scrollTop < 60) {
            $(window).off('.disqus_scroll');
            loadComments();
          }
        });
      }
    });
  
</script>





  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>

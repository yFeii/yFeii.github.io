<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="GCD系列 文章之线程同步与组，建议顺序为：概念，原理，之后在阅读本文">
<meta name="keywords" content="GCD">
<meta property="og:type" content="article">
<meta property="og:title" content="GCD之同步与组">
<meta property="og:url" content="http://yfeii.github.io/2020/03/07/GCD之同步与组/index.html">
<meta property="og:site_name" content="逆水行舟">
<meta property="og:description" content="GCD系列 文章之线程同步与组，建议顺序为：概念，原理，之后在阅读本文">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/gcd/454057FF-AA22-4F88-B0C3-F726BF0F2B8A.png">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/gcd/417D7790702704163098D5B8DE7D54D3.jpg">
<meta property="og:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/gcd/E5BB187F-3614-4DC4-9727-9C69C5C2AE12.png">
<meta property="og:updated_time" content="2020-03-12T03:07:00.776Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GCD之同步与组">
<meta name="twitter:description" content="GCD系列 文章之线程同步与组，建议顺序为：概念，原理，之后在阅读本文">
<meta name="twitter:image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/gcd/454057FF-AA22-4F88-B0C3-F726BF0F2B8A.png">





  
  
  <link rel="canonical" href="http://yfeii.github.io/2020/03/07/GCD之同步与组/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>GCD之同步与组 | 逆水行舟</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逆水行舟</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yfeii.github.io/2020/03/07/GCD之同步与组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yfeii">
      <meta itemprop="description" content="邮箱1486662452@qq.com，有问题欢迎留言评论或邮件。">
      <meta itemprop="image" content="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/profile/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逆水行舟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">GCD之同步与组

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-03-07 18:36:43" itemprop="dateCreated datePublished" datetime="2020-03-07T18:36:43+08:00">2020-03-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-03-12 11:07:00" itemprop="dateModified" datetime="2020-03-12T11:07:00+08:00">2020-03-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/多线程/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>GCD系列 文章之线程同步与组，建议顺序为：概念，原理，之后在阅读本文<a id="more"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>源码及版本号。所有源码均在苹果开源官网下可<a href="https://opensource.apple.com/" target="_blank" rel="noopener">下载</a><br>源码 | 版本<br>-|-<br>libdispatch | 1008.250.7<br>libpthread | 330.250.2<br>xnu | 6153.11.26</p>
<h2 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a>barrier</h2><p>在就讲过之前的<code>sync</code>和<code>async</code>之后，<code>barrier</code>函数就相对好理解了</p>
<h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><p><code>dispatch_barrier_sync</code>和<code>dispatch_sync</code>组合串行队列的流程相似，由于同步操作，当前面的任务执行时，后面任务会进入<code>wait</code>流程，关于等待与唤醒的方式，在前一篇已经有过说明。</p>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p><code>dispatch_barrier_async</code>和<code>dispatch_async</code>有所不同，在配合并行队列的情况下：经由<code>_dispatch_lane_concurrent_push<code>会进入到<code>_dispatch_lane_push<code>(回忆上篇异步并行的流程)。</code></code></code></code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_lane_push(dispatch_lane_t dq, dispatch_object_t dou,</span><br><span class="line">        dispatch_qos_t qos)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_wakeup_flags_t flags = <span class="number">0</span>;</span><br><span class="line">    struct dispatch_object_s *prev;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//barrier 不会走这里。</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(_dispatch_object_is_waiter(dou))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_lane_push_waiter(dq, dou._dsc, qos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatch_assert(!_dispatch_object_is_global(dq));</span><br><span class="line">    qos = _dispatch_queue_push_qos(dq, qos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are going to call dx_wakeup(), the queue must be retained before</span></span><br><span class="line">    <span class="comment">// the item we're pushing can be dequeued, which means:</span></span><br><span class="line">    <span class="comment">// - before we exchange the tail if we have to override</span></span><br><span class="line">    <span class="comment">// - before we set the head if we made the queue non empty.</span></span><br><span class="line">    <span class="comment">// Otherwise, if preempted between one of these and the call to dx_wakeup()</span></span><br><span class="line">    <span class="comment">// the blocks submitted to the queue may release the last reference to the</span></span><br><span class="line">    <span class="comment">// queue when invoked by _dispatch_lane_drain. &lt;rdar://problem/6932776&gt;</span></span><br><span class="line"></span><br><span class="line">    prev = os_mpsc_push_update_tail(os_mpsc(dq, dq_items), dou._do, do_next);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(os_mpsc_push_was_empty(prev))) &#123;</span><br><span class="line">        _dispatch_retain_2_unsafe(dq);</span><br><span class="line">        flags = DISPATCH_WAKEUP_CONSUME_2 | DISPATCH_WAKEUP_MAKE_DIRTY;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(_dispatch_queue_need_override(dq, qos))) &#123;</span><br><span class="line">        <span class="comment">// There's a race here, _dispatch_queue_need_override may read a stale</span></span><br><span class="line">        <span class="comment">// dq_state value.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// If it's a stale load from the same drain streak, given that</span></span><br><span class="line">        <span class="comment">// the max qos is monotonic, too old a read can only cause an</span></span><br><span class="line">        <span class="comment">// unnecessary attempt at overriding which is harmless.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// We'll assume here that a stale load from an a previous drain streak</span></span><br><span class="line">        <span class="comment">// never happens in practice.</span></span><br><span class="line">        _dispatch_retain_2_unsafe(dq);</span><br><span class="line">        flags = DISPATCH_WAKEUP_CONSUME_2;</span><br><span class="line">    &#125;</span><br><span class="line">    os_mpsc_push_update_prev(os_mpsc(dq, dq_items), prev, dou._do, do_next);</span><br><span class="line">    <span class="keyword">if</span> (flags) &#123;</span><br><span class="line">        <span class="keyword">return</span> dx_wakeup(dq, qos, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里最终会调用到<code>dx_wakeup</code>即：_dispatch_lane_wakeup。<br>这个函数内部会调用<code>_dispatch_queue_wakeup</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_queue_wakeup(dispatch_queue_class_t dqu, dispatch_qos_t qos,</span><br><span class="line">        dispatch_wakeup_flags_t flags, dispatch_queue_wakeup_target_t target)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_queue_t dq = dqu._dq;</span><br><span class="line">    dispatch_assert(target != DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target &amp;&amp; !(flags &amp; DISPATCH_WAKEUP_CONSUME_2)) &#123;</span><br><span class="line">        _dispatch_retain_2(dq);</span><br><span class="line">        flags |= DISPATCH_WAKEUP_CONSUME_2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(flags &amp; DISPATCH_WAKEUP_BARRIER_COMPLETE)) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// _dispatch_lane_class_barrier_complete() is about what both regular</span></span><br><span class="line">        <span class="comment">// queues and sources needs to evaluate, but the former can have sync</span></span><br><span class="line">        <span class="comment">// handoffs to perform which _dispatch_lane_class_barrier_complete()</span></span><br><span class="line">        <span class="comment">// doesn't handle, only _dispatch_lane_barrier_complete() does.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// _dispatch_lane_wakeup() is the one for plain queues that calls</span></span><br><span class="line">        <span class="comment">// _dispatch_lane_barrier_complete(), and this is only taken for non</span></span><br><span class="line">        <span class="comment">// queue types.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        dispatch_assert(dx_metatype(dq) == _DISPATCH_SOURCE_TYPE);</span><br><span class="line">        qos = _dispatch_queue_wakeup_qos(dq, qos);</span><br><span class="line">        <span class="keyword">return</span> _dispatch_lane_class_barrier_complete(upcast(dq)._dl, qos,</span><br><span class="line">                flags, target, DISPATCH_QUEUE_SERIAL_DRAIN_OWNED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//barrier 会这走这里。</span></span><br><span class="line">    <span class="keyword">if</span> (target) &#123;</span><br><span class="line">        uint64_t old_state, new_state, enqueue = DISPATCH_QUEUE_ENQUEUED;</span><br><span class="line">        <span class="keyword">if</span> (target == DISPATCH_QUEUE_WAKEUP_MGR) &#123;</span><br><span class="line">            enqueue = DISPATCH_QUEUE_ENQUEUED_ON_MGR;</span><br><span class="line">        &#125;</span><br><span class="line">        qos = _dispatch_queue_wakeup_qos(dq, qos);</span><br><span class="line">        os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, release, &#123;</span><br><span class="line">            new_state = _dq_state_merge_qos(old_state, qos);</span><br><span class="line">            <span class="keyword">if</span> (likely(!_dq_state_is_suspended(old_state) &amp;&amp;</span><br><span class="line">                    !_dq_state_is_enqueued(old_state) &amp;&amp;</span><br><span class="line">                    (!_dq_state_drain_locked(old_state) ||</span><br><span class="line">                    (enqueue != DISPATCH_QUEUE_ENQUEUED_ON_MGR &amp;&amp;</span><br><span class="line">                    _dq_state_is_base_wlh(old_state))))) &#123;</span><br><span class="line">                new_state |= enqueue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; DISPATCH_WAKEUP_MAKE_DIRTY) &#123;</span><br><span class="line">                new_state |= DISPATCH_QUEUE_DIRTY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (new_state == old_state) &#123;</span><br><span class="line">                os_atomic_rmw_loop_give_up(goto done);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (likely((old_state ^ new_state) &amp; enqueue)) &#123;</span><br><span class="line">            dispatch_queue_t tq;</span><br><span class="line">            <span class="keyword">if</span> (target == DISPATCH_QUEUE_WAKEUP_TARGET) &#123;</span><br><span class="line">                <span class="comment">// the rmw_loop above has no acquire barrier, as the last block</span></span><br><span class="line">                <span class="comment">// of a queue asyncing to that queue is not an uncommon pattern</span></span><br><span class="line">                <span class="comment">// and in that case the acquire would be completely useless</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// so instead use depdendency ordering to read</span></span><br><span class="line">                <span class="comment">// the targetq pointer.</span></span><br><span class="line">                os_atomic_thread_fence(dependency);</span><br><span class="line">                tq = os_atomic_load_with_dependency_on2o(dq, do_targetq,</span><br><span class="line">                        (long)new_state);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tq = target;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch_assert(_dq_state_is_enqueued(new_state));</span><br><span class="line">            <span class="keyword">return</span> _dispatch_queue_push_queue(tq, dq, new_state);</span><br><span class="line">        &#125;</span><br><span class="line">#if HAVE_PTHREAD_WORKQUEUE_QOS</span><br><span class="line">        <span class="keyword">if</span> (unlikely((old_state ^ new_state) &amp; DISPATCH_QUEUE_MAX_QOS_MASK)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_dq_state_should_override(new_state)) &#123;</span><br><span class="line">                <span class="keyword">return</span> _dispatch_queue_wakeup_with_override(dq, new_state,</span><br><span class="line">                        flags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qos) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Someone is trying to override the last work item of the queue.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        uint64_t old_state, new_state;</span><br><span class="line">        os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, relaxed, &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_dq_state_drain_locked(old_state) ||</span><br><span class="line">                    !_dq_state_is_enqueued(old_state)) &#123;</span><br><span class="line">                os_atomic_rmw_loop_give_up(goto done);</span><br><span class="line">            &#125;</span><br><span class="line">            new_state = _dq_state_merge_qos(old_state, qos);</span><br><span class="line">            <span class="keyword">if</span> (new_state == old_state) &#123;</span><br><span class="line">                os_atomic_rmw_loop_give_up(goto done);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (_dq_state_should_override(new_state)) &#123;</span><br><span class="line">            <span class="keyword">return</span> _dispatch_queue_wakeup_with_override(dq, new_state, flags);</span><br><span class="line">        &#125;</span><br><span class="line">#endif // HAVE_PTHREAD_WORKQUEUE_QOS</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">if</span> (likely(flags &amp; DISPATCH_WAKEUP_CONSUME_2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_release_2_tailcall(dq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>_dispatch_queue_push_queue</code>会进一步调用<code>_dispatch_root_queue_push</code>在前一篇已经分析过流程，但是在<code>barrier</code>的异步流程中，并不会每次都开启新的线程。</p>
<p>接下来在看一下任务的执行<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/gcd/454057FF-AA22-4F88-B0C3-F726BF0F2B8A.png" alt="semaphore"><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> dispatch_queue_wakeup_target_t</span><br><span class="line">_dispatch_lane_concurrent_drain(dispatch_lane_class_t dqu,</span><br><span class="line">        dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags,</span><br><span class="line">        uint64_t *owned)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_lane_drain(dqu._dl, dic, flags, owned, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> dispatch_queue_wakeup_target_t</span><br><span class="line">_dispatch_lane_drain(dispatch_lane_t dq, dispatch_invoke_context_t dic,</span><br><span class="line">        dispatch_invoke_flags_t flags, uint64_t *owned_ptr, bool serial_drain)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_queue_t orig_tq = dq-&gt;do_targetq;</span><br><span class="line">    dispatch_thread_frame_s dtf;</span><br><span class="line">    struct dispatch_object_s *dc = NULL, *next_dc;</span><br><span class="line">    uint64_t dq_state, owned = *owned_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!dq-&gt;dq_items_tail)) <span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">    _dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">    <span class="keyword">if</span> (serial_drain || _dq_state_is_in_barrier(owned)) &#123;</span><br><span class="line">        <span class="comment">// we really own `IN_BARRIER + dq-&gt;dq_width * WIDTH_INTERVAL`</span></span><br><span class="line">        <span class="comment">// but width can change while draining barrier work items, so we only</span></span><br><span class="line">        <span class="comment">// convert to `dq-&gt;dq_width * WIDTH_INTERVAL` when we drop `IN_BARRIER`</span></span><br><span class="line">        owned = DISPATCH_QUEUE_IN_BARRIER;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        owned &amp;= DISPATCH_QUEUE_WIDTH_MASK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dc = _dispatch_queue_get_head(dq);</span><br><span class="line">    goto first_iteration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        dispatch_assert(dic-&gt;dic_barrier_waiter == NULL);</span><br><span class="line">        dc = next_dc;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dispatch_needs_to_return_to_kernel())) &#123;</span><br><span class="line">            _dispatch_return_to_kernel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(!dc)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dq-&gt;dq_items_tail) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dc = _dispatch_queue_get_head(dq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(serial_drain != (dq-&gt;dq_width == <span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dispatch_queue_drain_should_narrow(dic))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (likely(flags &amp; DISPATCH_INVOKE_WORKLOOP_DRAIN)) &#123;</span><br><span class="line">            dispatch_workloop_t dwl = (dispatch_workloop_t)_dispatch_get_wlh();</span><br><span class="line">            <span class="keyword">if</span> (unlikely(_dispatch_queue_max_qos(dwl) &gt; dwl-&gt;dwl_drained_qos)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">first_iteration:</span><br><span class="line">        dq_state = os_atomic_load(&amp;dq-&gt;dq_state, relaxed);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dq_state_is_suspended(dq_state))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(orig_tq != dq-&gt;do_targetq)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (serial_drain || _dispatch_object_is_barrier(dc)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!serial_drain &amp;&amp; owned != DISPATCH_QUEUE_IN_BARRIER) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!_dispatch_queue_try_upgrade_full_width(dq, owned)) &#123;</span><br><span class="line">                    goto out_with_no_width;</span><br><span class="line">                &#125;</span><br><span class="line">                owned = DISPATCH_QUEUE_IN_BARRIER;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (_dispatch_object_is_sync_waiter(dc) &amp;&amp;</span><br><span class="line">                    !(flags &amp; DISPATCH_INVOKE_THREAD_BOUND)) &#123;</span><br><span class="line">                dic-&gt;dic_barrier_waiter = dc;</span><br><span class="line">                goto out_with_barrier_waiter;</span><br><span class="line">            &#125;</span><br><span class="line">            next_dc = _dispatch_queue_pop_head(dq, dc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (owned == DISPATCH_QUEUE_IN_BARRIER) &#123;</span><br><span class="line">                <span class="comment">// we just ran barrier work items, we have to make their</span></span><br><span class="line">                <span class="comment">// effect visible to other sync work items on other threads</span></span><br><span class="line">                <span class="comment">// that may start coming in after this point, hence the</span></span><br><span class="line">                <span class="comment">// release barrier</span></span><br><span class="line">                os_atomic_xor2o(dq, dq_state, owned, release);</span><br><span class="line">                owned = dq-&gt;dq_width * DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(owned == <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_dispatch_object_is_waiter(dc)) &#123;</span><br><span class="line">                    <span class="comment">// sync "readers" don't observe the limit</span></span><br><span class="line">                    _dispatch_queue_reserve_sync_width(dq);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!_dispatch_queue_try_acquire_async(dq)) &#123;</span><br><span class="line">                    goto out_with_no_width;</span><br><span class="line">                &#125;</span><br><span class="line">                owned = DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            next_dc = _dispatch_queue_pop_head(dq, dc);</span><br><span class="line">            <span class="keyword">if</span> (_dispatch_object_is_waiter(dc)) &#123;</span><br><span class="line">                owned -= DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">                _dispatch_non_barrier_waiter_redirect_or_wake(dq, dc);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; DISPATCH_INVOKE_REDIRECTING_DRAIN) &#123;</span><br><span class="line">                owned -= DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">                <span class="comment">// This is a re-redirect, overrides have already been applied by</span></span><br><span class="line">                <span class="comment">// _dispatch_continuation_async*</span></span><br><span class="line">                <span class="comment">// However we want to end up on the root queue matching `dc`</span></span><br><span class="line">                <span class="comment">// qos, so pick up the current override of `dq` which includes</span></span><br><span class="line">                <span class="comment">// dc's override (and maybe more)</span></span><br><span class="line">                _dispatch_continuation_redirect_push(dq, dc,</span><br><span class="line">                        _dispatch_queue_max_qos(dq));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _dispatch_continuation_pop_inline(dc, dic, flags, dq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (owned == DISPATCH_QUEUE_IN_BARRIER) &#123;</span><br><span class="line">        <span class="comment">// if we're IN_BARRIER we really own the full width too</span></span><br><span class="line">        owned += dq-&gt;dq_width * DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dc) &#123;</span><br><span class="line">        owned = _dispatch_queue_adjust_owned(dq, owned, dc);</span><br><span class="line">    &#125;</span><br><span class="line">    *owned_ptr &amp;= DISPATCH_QUEUE_ENQUEUED | DISPATCH_QUEUE_ENQUEUED_ON_MGR;</span><br><span class="line">    *owned_ptr |= owned;</span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">    <span class="keyword">return</span> dc ? dq-&gt;do_targetq : NULL;</span><br><span class="line"></span><br><span class="line">out_with_no_width:</span><br><span class="line">    *owned_ptr &amp;= DISPATCH_QUEUE_ENQUEUED | DISPATCH_QUEUE_ENQUEUED_ON_MGR;</span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">    <span class="keyword">return</span> DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT;</span><br><span class="line"></span><br><span class="line">out_with_barrier_waiter:</span><br><span class="line">    <span class="keyword">if</span> (unlikely(flags &amp; DISPATCH_INVOKE_DISALLOW_SYNC_WAITERS)) &#123;</span><br><span class="line">        DISPATCH_INTERNAL_CRASH(<span class="number">0</span>,</span><br><span class="line">                <span class="string">"Deferred continuation on source, mach channel or mgr"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">    <span class="keyword">return</span> dq-&gt;do_targetq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先来看一组log<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/gcd/417D7790702704163098D5B8DE7D54D3.jpg" alt="log"><br>对于<code>barrier</code>的异步实现比较巧妙，首先我们来想一个问题，要实现这种“异步等待”的策略，必然要使得<code>barrier_async</code>那样具有wait的相关函数。</p>
<p>首先我们知道<code>GCD</code>的队列都是FIFO 的，那么是否可以开启一个专用的栅栏线程，来执行这个FIFO的队列，从而形成一个类似barrier的功能呢。再来解释一下，当只有一个线程来调度队列时，因为队列FIFO的特性，使得这个队列的任务执行都是按顺序(前一个任务执行完，再执行后一个)。</p>
<p>在异步并发的场景下，<code>GCD</code>的队列仍然遵循FIFO的规则，但是由于每一次<code>dispatch_async</code>都会开辟一个线程，因此会有多个线程来执行多个队列任务。</p>
<blockquote>
<p>A concurrent dispatch queue is useful when you have multiple tasks that can run in parallel. A concurrent queue is still a queue in that it dequeues tasks in a first-in, first-out order; however, a concurrent queue may dequeue additional tasks before any previous tasks finish. </p>
</blockquote>
<p>值得注意的一点：<code>barrier</code>对于全局队列无效。</p>
<h3 id="barrier总结"><a href="#barrier总结" class="headerlink" title="barrier总结"></a>barrier总结</h3><p>在异步的场景，因为<code>GCD</code>队列是<code>FIFO</code>的，所以<code>barrier_async</code>只要保证只有一个线程在 执行block 就形成了 栅栏。</p>
<p>在同步场景下，<code>barrier</code>使用了和<code>dispatch_sync</code>一样的<code>wait</code>函数来实现同步。</p>
<p>但是<code>barrier_sync</code>不能采用类似<code>barrier_async</code>的做法：</p>
<ol>
<li>同步函数没有开辟线程的能力。</li>
<li>同步是在当前线程执行栅栏，当前线程也有可能是多个异步(async 嵌套 sync 这样)，因此这种情况下barrier_sync要有阻塞(wait)的能力。</li>
</ol>
<h2 id="semaphore"><a href="#semaphore" class="headerlink" title="semaphore"></a>semaphore</h2><p>信号量是泛化的互斥体，互斥体只能是0和1，但信号量是：取值可以达到某个正数，即允许并发持有信号量的持有者的个数。</p>
<p><code>GCD</code>的信号量也是基于 mach 信号。<br><img src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/gcd/E5BB187F-3614-4DC4-9727-9C69C5C2AE12.png" alt="semaphore"></p>
<h3 id="dispatch-semaphore-wait"><a href="#dispatch-semaphore-wait" class="headerlink" title="dispatch_semaphore_wait"></a>dispatch_semaphore_wait</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">long</span><br><span class="line">dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//原子性减1  dec = -</span></span><br><span class="line">    long value = os_atomic_dec2o(dsema, dsema_value, acquire);</span><br><span class="line">    <span class="keyword">if</span> (likely(value &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">//有资源直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_semaphore_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_semaphore_wait</code>会使信号量原子性-1，然后进行等待或直接返回，等待的策略如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> long</span><br><span class="line">_dispatch_semaphore_wait_slow(dispatch_semaphore_t dsema,</span><br><span class="line">        dispatch_time_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">    long orig;</span><br><span class="line"></span><br><span class="line">    _dispatch_sema4_create(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">    <span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (!_dispatch_sema4_timedwait(&amp;dsema-&gt;dsema_sema, timeout)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Fall through and try to undo what the fast path did to</span></span><br><span class="line">        <span class="comment">// dsema-&gt;dsema_value</span></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">        orig = dsema-&gt;dsema_value;</span><br><span class="line">        <span class="keyword">while</span> (orig &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (os_atomic_cmpxchgvw2o(dsema, dsema_value, orig, orig + <span class="number">1</span>,</span><br><span class="line">                    &amp;orig, relaxed)) &#123;</span><br><span class="line">                <span class="keyword">return</span> _DSEMA4_TIMEOUT();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Another thread called semaphore_signal().</span></span><br><span class="line">        <span class="comment">// Fall through and drain the wakeup.</span></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">        _dispatch_sema4_wait(&amp;dsema-&gt;dsema_sema);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据<code>timeout</code>的参数不同，等待不同的时间，<code>DISPATCH_TIME_FOREVER</code>会调用<code>_dispatch_sema4_wait</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_sema4_wait(_dispatch_sema4_t *sema)</span><br><span class="line">&#123;</span><br><span class="line">    kern_return_t kr;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        kr = semaphore_wait(*sema);</span><br><span class="line">    &#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line">    DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与之配套的signal<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line">long</span><br><span class="line">_dispatch_semaphore_signal_slow(dispatch_semaphore_t dsema)</span><br><span class="line">&#123;</span><br><span class="line">    _dispatch_sema4_create(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">    _dispatch_sema4_signal(&amp;dsema-&gt;dsema_sema, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long</span><br><span class="line">dispatch_semaphore_signal(dispatch_semaphore_t dsema)</span><br><span class="line">&#123;</span><br><span class="line">    long value = os_atomic_inc2o(dsema, dsema_value, release);</span><br><span class="line">    <span class="comment">//如果当前有可用资源(信号量&gt;0)，则不作任何操作</span></span><br><span class="line">    <span class="keyword">if</span> (likely(value &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(value == LONG_MIN)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(value,</span><br><span class="line">                <span class="string">"Unbalanced call to dispatch_semaphore_signal()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要发送信号量</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_semaphore_signal_slow(dsema);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_sema4_signal(_dispatch_sema4_t *sema, long count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        kern_return_t kr = semaphore_signal(*sema);</span><br><span class="line">        DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">    &#125; <span class="keyword">while</span> (--count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>信号量总体来说比较简单。值得注意的点就是当信号量销毁时，如果当前的信号值和初始值不一致，会引发crash<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_semaphore_dispose(dispatch_object_t dou,</span><br><span class="line">        DISPATCH_UNUSED bool *allow_free)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_semaphore_t dsema = dou._dsema;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_value &lt; dsema-&gt;dsema_orig) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(dsema-&gt;dsema_orig - dsema-&gt;dsema_value,</span><br><span class="line">                <span class="string">"Semaphore object deallocated while in use"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_sema4_dispose(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="group"><a href="#group" class="headerlink" title="group"></a>group</h2><p>关于<code>dispatch_group<code>的定义在code&gt;semaphore.c<code>中，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> inline dispatch_group_t</span><br><span class="line">_dispatch_group_create_with_count(uint32_t n)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_group_t dg = _dispatch_object_alloc(DISPATCH_VTABLE(group),</span><br><span class="line">            sizeof(struct dispatch_group_s));</span><br><span class="line">    dg-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">    dg-&gt;do_targetq = _dispatch_get_default_queue(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (n) &#123;</span><br><span class="line">        os_atomic_store2o(dg, dg_bits,</span><br><span class="line">                -n * DISPATCH_GROUP_VALUE_INTERVAL, relaxed);</span><br><span class="line">        os_atomic_store2o(dg, do_ref_cnt, <span class="number">1</span>, relaxed); <span class="comment">// &lt;rdar://22318411&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_group_t</span><br><span class="line">dispatch_group_create(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_group_create_with_count(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></code></code></p>
<p>group采用和信号量类似的思想，通过存储count的值来判断notify的操作。<br>而对应信号量的wait 和 signal有<code>enter</code><code>leave</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_leave(dispatch_group_t dg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The value is incremented on a 64bits wide atomic so that the carry for</span></span><br><span class="line">    <span class="comment">// the -1 -&gt; 0 transition increments the generation atomically.</span></span><br><span class="line">    uint64_t new_state, old_state = os_atomic_add_orig2o(dg, dg_state,</span><br><span class="line">            DISPATCH_GROUP_VALUE_INTERVAL, release);</span><br><span class="line">    uint32_t old_value = (uint32_t)(old_state &amp; DISPATCH_GROUP_VALUE_MASK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(old_value == DISPATCH_GROUP_VALUE_1)) &#123;</span><br><span class="line">        old_state += DISPATCH_GROUP_VALUE_INTERVAL;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            new_state = old_state;</span><br><span class="line">            <span class="keyword">if</span> ((old_state &amp; DISPATCH_GROUP_VALUE_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line">                new_state &amp;= ~DISPATCH_GROUP_HAS_WAITERS;</span><br><span class="line">                new_state &amp;= ~DISPATCH_GROUP_HAS_NOTIFS;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// If the group was entered again since the atomic_add above,</span></span><br><span class="line">                <span class="comment">// we can't clear the waiters bit anymore as we don't know for</span></span><br><span class="line">                <span class="comment">// which generation the waiters are for</span></span><br><span class="line">                new_state &amp;= ~DISPATCH_GROUP_HAS_NOTIFS;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (old_state == new_state) <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (unlikely(!os_atomic_cmpxchgv2o(dg, dg_state,</span><br><span class="line">                old_state, new_state, &amp;old_state, relaxed)));</span><br><span class="line">        <span class="keyword">return</span> _dispatch_group_wake(dg, old_state, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(old_value == <span class="number">0</span>)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH((uintptr_t)old_value,</span><br><span class="line">                <span class="string">"Unbalanced call to dispatch_group_leave()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_enter(dispatch_group_t dg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The value is decremented on a 32bits wide atomic so that the carry</span></span><br><span class="line">    <span class="comment">// for the 0 -&gt; -1 transition is not propagated to the upper 32bits.</span></span><br><span class="line">    uint32_t old_bits = os_atomic_sub_orig2o(dg, dg_bits,</span><br><span class="line">            DISPATCH_GROUP_VALUE_INTERVAL, acquire);</span><br><span class="line">    uint32_t old_value = old_bits &amp; DISPATCH_GROUP_VALUE_MASK;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(old_value == <span class="number">0</span>)) &#123;</span><br><span class="line">        _dispatch_retain(dg); <span class="comment">// &lt;rdar://problem/22318411&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(old_value == DISPATCH_GROUP_VALUE_MAX)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(old_bits,</span><br><span class="line">                <span class="string">"Too many nested calls to dispatch_group_enter()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总体来说<code>group</code>的实现方式比较简单，其中不乏借鉴了信号量的思想。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="API注意事项"><a href="#API注意事项" class="headerlink" title="API注意事项"></a>API注意事项</h3><p>多线程需要注意的点一个是多线程技术带来的数据竞争问题，一个是防止数据竞争带来的死锁问题。</p>
<h4 id="死锁的条件"><a href="#死锁的条件" class="headerlink" title="死锁的条件"></a>死锁的条件</h4><p>死锁的四个必要条件：  </p>
<p>互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p>
<p>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p>
<p>不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</p>
<p>循环等待条件: 若干进程间形成首尾相接循环等待资源的关系。</p>
<p>对于GCD的同步API都应注意。</p>
<h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><h4 id="架构分层"><a href="#架构分层" class="headerlink" title="架构分层"></a>架构分层</h4><p>从GCD的整个流程扩展开来看，我们能够看到<code>架构分层</code>设计思想：<code>Mach</code>提供基础的原始API，由上层的<code>BSD</code>实现不同的功能扩展。  也包括<code>libdispatch</code> -&gt; <code>libpthread</code> -&gt; <code>xnu</code>的分层。</p>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>在前面的<code>malloc</code>源码也见过同样的设计，只不过由原来的<code>zone</code>的继承，变成了<code>GCD</code>的结构体嵌套。为了时这些队列操作对象都具有相同的行为，采用了<code>vtable</code>的函数表设计，并关联在对应的结构体对象上，还有对应的类簇结构体。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/GCD/" rel="tag"># GCD</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/26/GCD之线程原理向/" rel="next" title="GCD之线程原理向">
                <i class="fa fa-chevron-left"></i> GCD之线程原理向
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/25/深入理解iOS中的锁/" rel="prev" title="深入理解iOS中的锁">
                深入理解iOS中的锁 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://yfeii-blog.oss-cn-hangzhou.aliyuncs.com/profile/avatar.png" alt="yfeii">
            
              <p class="site-author-name" itemprop="name">yfeii</p>
              <div class="site-description motion-element" itemprop="description">邮箱1486662452@qq.com，有问题欢迎留言评论或邮件。</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#背景"><span class="nav-number">1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#barrier"><span class="nav-number">2.</span> <span class="nav-text">barrier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sync"><span class="nav-number">2.1.</span> <span class="nav-text">sync</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#async"><span class="nav-number">2.2.</span> <span class="nav-text">async</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#barrier总结"><span class="nav-number">2.3.</span> <span class="nav-text">barrier总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#semaphore"><span class="nav-number">3.</span> <span class="nav-text">semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-semaphore-wait"><span class="nav-number">3.1.</span> <span class="nav-text">dispatch_semaphore_wait</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#group"><span class="nav-number">4.</span> <span class="nav-text">group</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#API注意事项"><span class="nav-number">5.1.</span> <span class="nav-text">API注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁的条件"><span class="nav-number">5.1.1.</span> <span class="nav-text">死锁的条件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计思想"><span class="nav-number">5.2.</span> <span class="nav-text">设计思想</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#架构分层"><span class="nav-number">5.2.1.</span> <span class="nav-text">架构分层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面向对象"><span class="nav-number">5.2.2.</span> <span class="nav-text">面向对象</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yfeii</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/affix.js?v=7.1.1"></script>

  <script src="/js/schemes/pisces.js?v=7.1.1"></script>



  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
